{"version":3,"file":"jsstore.worker.min.js","mappings":"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","sources":["webpack://JsStoreWorker/webpack/bootstrap","webpack://JsStoreWorker/webpack/runtime/define property getters","webpack://JsStoreWorker/webpack/runtime/hasOwnProperty shorthand","webpack://JsStoreWorker/webpack/runtime/make namespace object","webpack://JsStoreWorker/./src/common/utils/promise_resolve.ts","webpack://JsStoreWorker/./src/common/enums.ts","webpack://JsStoreWorker/./src/common/utils/promise.ts","webpack://JsStoreWorker/./src/worker/model/table_meta.ts","webpack://JsStoreWorker/./src/worker/meta_helper.ts","webpack://JsStoreWorker/./src/worker/model/db_meta.ts","webpack://JsStoreWorker/./src/common/utils/for_obj.ts","webpack://JsStoreWorker/./src/worker/utils/log_helper.ts","webpack://JsStoreWorker/./src/worker/idbutil/index.ts","webpack://JsStoreWorker/./src/common/utils/promise_all.ts","webpack://JsStoreWorker/./src/worker/utils/promise_reject.ts","webpack://JsStoreWorker/./src/worker/utils/get_error.ts","webpack://JsStoreWorker/./src/worker/executors/base.ts","webpack://JsStoreWorker/./src/worker/utils/get_error_from_exception.ts","webpack://JsStoreWorker/./src/worker/utils/get_data_type.ts","webpack://JsStoreWorker/./src/worker/utils/is_null.ts","webpack://JsStoreWorker/./src/worker/executors/insert/values_checker.ts","webpack://JsStoreWorker/./src/worker/executors/update/schema_checker.ts","webpack://JsStoreWorker/./src/worker/executors/query_helper.ts","webpack://JsStoreWorker/./src/worker/executors/insert/index.ts","webpack://JsStoreWorker/./src/worker/constants/index.ts","webpack://JsStoreWorker/./src/worker/utils/set_cross_browser_idb.ts","webpack://JsStoreWorker/./src/worker/utils/is_array.ts","webpack://JsStoreWorker/./src/worker/utils/get_keys.ts","webpack://JsStoreWorker/./src/worker/utils/get_length.ts","webpack://JsStoreWorker/./src/worker/utils/get_object_first_key.ts","webpack://JsStoreWorker/./src/worker/executors/select/then_evaluator.ts","webpack://JsStoreWorker/./src/worker/executors/select/where.ts","webpack://JsStoreWorker/./src/worker/executors/select/not_where.ts","webpack://JsStoreWorker/./src/worker/utils/remove_space.ts","webpack://JsStoreWorker/./src/worker/executors/select/order_by.ts","webpack://JsStoreWorker/./src/worker/utils/get_regex_from_like.ts","webpack://JsStoreWorker/./src/worker/utils/clone.ts","webpack://JsStoreWorker/./src/worker/utils/compare.ts","webpack://JsStoreWorker/./src/worker/executors/where_checker.ts","webpack://JsStoreWorker/./src/worker/executors/base_fetch.ts","webpack://JsStoreWorker/./src/worker/executors/select/regex.ts","webpack://JsStoreWorker/./src/worker/executors/select/join.ts","webpack://JsStoreWorker/./src/worker/memory_store/index.ts","webpack://JsStoreWorker/./src/worker/executors/select/index.ts","webpack://JsStoreWorker/./src/worker/utils/is_object.ts","webpack://JsStoreWorker/./src/worker/executors/select/in.ts","webpack://JsStoreWorker/./src/worker/executors/select/base_select.ts","webpack://JsStoreWorker/./src/worker/executors/select/group_by.ts","webpack://JsStoreWorker/./src/worker/executors/count/not_where.ts","webpack://JsStoreWorker/./src/worker/executors/count/where.ts","webpack://JsStoreWorker/./src/worker/executors/count/index.ts","webpack://JsStoreWorker/./src/worker/executors/count/regex.ts","webpack://JsStoreWorker/./src/worker/executors/count/in.ts","webpack://JsStoreWorker/./src/worker/utils/resolve.ts","webpack://JsStoreWorker/./src/worker/executors/update/update_value.ts","webpack://JsStoreWorker/./src/worker/executors/update/index.ts","webpack://JsStoreWorker/./src/worker/executors/update/not_where.ts","webpack://JsStoreWorker/./src/worker/executors/update/where.ts","webpack://JsStoreWorker/./src/worker/executors/update/regex.ts","webpack://JsStoreWorker/./src/worker/executors/update/in.ts","webpack://JsStoreWorker/./src/worker/intersect/index.ts","webpack://JsStoreWorker/./src/worker/executors/drop_db.ts","webpack://JsStoreWorker/./src/worker/union/index.ts","webpack://JsStoreWorker/./src/worker/executors/remove/where.ts","webpack://JsStoreWorker/./src/worker/executors/remove/index.ts","webpack://JsStoreWorker/./src/worker/executors/remove/in.ts","webpack://JsStoreWorker/./src/worker/executors/remove/not_where.ts","webpack://JsStoreWorker/./src/worker/executors/remove/regex.ts","webpack://JsStoreWorker/./src/worker/executors/clear/index.ts","webpack://JsStoreWorker/./src/worker/executors/transaction/index.ts","webpack://JsStoreWorker/./src/worker/utils/db_schema.ts","webpack://JsStoreWorker/./src/worker/query_manager.ts","webpack://JsStoreWorker/./src/worker/index.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export const promiseResolve = (value?) => {\n    return Promise.resolve(value);\n}","import { IErrorType } from \"./interfaces\";\n\nexport const ERROR_TYPE = {\n    InvalidUpdateColumn: \"invalid_update_column\",\n    UndefinedColumn: \"undefined_column\",\n    UndefinedValue: \"undefined_value\",\n    UndefinedColumnName: \"undefined_column_name\",\n    UndefinedDbName: \"undefined_database_name\",\n    UndefinedColumnValue: \"undefined_column_value\",\n    NotArray: \"not_array\",\n    NoValueSupplied: \"no_value_supplied\",\n    ColumnNotExist: \"column_not_exist\",\n    NoIndexFound: \"no_index_found\",\n    InvalidOp: \"invalid_operator\",\n    NullValue: \"null_value\",\n    WrongDataType: \"wrong_data_type\",\n    TableNotExist: \"table_not_exist\",\n    DbNotExist: \"db_not_exist\",\n    ConnectionAborted: \"connection_aborted\",\n    ConnectionClosed: \"connection_closed\",\n    NotObject: \"not_object\",\n    InvalidConfig: \"invalid_config\",\n    DbBlocked: \"Db_blocked\",\n    IndexedDbNotSupported: \"indexeddb_not_supported\",\n    NullValueInWhere: \"null_value_in_where\",\n    InvalidJoinQuery: 'invalid_join_query',\n    InvalidQuery: 'invalid_query',\n    ImportScriptsFailed: 'import_scripts_failed',\n    MethodNotExist: 'method_not_exist',\n    Unknown: \"unknown\",\n    InvalidMiddleware: \"invalid_middleware\"\n} as IErrorType;\n\nif (process.env.NODE_ENV !== 'production') {\n    Object.assign(ERROR_TYPE, {\n        InvalidOrderQuery: 'invalid_order_query',\n        InvalidGroupQuery: 'invalid_group_query'\n    });\n}\n\nexport enum WORKER_STATUS {\n    Registered = \"registerd\",\n    Failed = \"failed\",\n    NotStarted = \"not_started\"\n}\n\nexport enum DATA_TYPE {\n    String = \"string\",\n    Object = \"object\",\n    Array = \"array\",\n    Number = \"number\",\n    Boolean = \"boolean\",\n    Null = \"null\",\n    DateTime = \"date_time\"\n}\n\n\nexport enum API {\n    InitDb = \"init_db\",\n    MapGet = \"map_get\",\n    MapSet = \"map_set\",\n    MapHas = \"map_has\",\n    MapDelete = \"map_delete\",\n    Select = \"select\",\n    Insert = \"insert\",\n    Update = \"update\",\n    Remove = \"remove\",\n    OpenDb = \"open_db\",\n    Clear = \"clear\",\n    DropDb = \"drop_db\",\n    Count = \"count\",\n    ChangeLogStatus = \"change_log_status\",\n    Terminate = \"terminate\",\n    Transaction = \"transaction\",\n    CloseDb = \"close_db\",\n    Union = \"union\",\n    Intersect = \"intersect\",\n    ImportScripts = \"import_scripts\",\n    Middleware = \"middleware\"\n}\n\nexport enum EVENT {\n    RequestQueueEmpty = \"requestQueueEmpty\",\n    RequestQueueFilled = \"requestQueueFilled\",\n    Upgrade = \"upgrade\",\n    Create = \"create\",\n    Open = \"open\"\n}\n\nexport enum QUERY_OPTION {\n    Where = \"where\",\n    Like = 'like',\n    Regex = 'regex',\n    In = 'in',\n    Equal = \"=\",\n    Between = '-',\n    GreaterThan = '>',\n    LessThan = '<',\n    GreaterThanEqualTo = \">=\",\n    LessThanEqualTo = \"<=\",\n    NotEqualTo = \"!=\",\n    Aggregate = \"aggregate\",\n    Max = \"max\",\n    Min = \"min\",\n    Avg = \"avg\",\n    Count = \"count\",\n    Sum = \"sum\",\n    List = \"list\",\n    Or = \"or\",\n    Skip = \"skip\",\n    Limit = \"limit\",\n    And = \"and\",\n    IgnoreCase = \"ignoreCase\",\n    Then = \"then\"\n}\n\nexport enum IDB_MODE {\n    ReadOnly = \"readonly\",\n    ReadWrite = \"readwrite\"\n}\n\nexport enum OCCURENCE {\n    First = 'f',\n    Last = 'l',\n    Any = 'a'\n}\n\nexport enum CONNECTION_STATUS {\n    Connected = \"connected\",\n    Closed = \"closed\",\n    NotStarted = \"not_started\",\n    UnableToStart = \"unable_to_start\",\n    ClosedByJsStore = \"closed_by_jsstore\"\n}","export const promise = <T>(cb: (res, rej?) => any) => {\n    return new Promise<T>(cb);\n}","import { ITable, IAlterQuery, IColumn, TColumns } from \"@/common\";\n\nexport class TableMeta {\n    name: string;\n    columns: IColumn[] = [];\n    primaryKey: string;\n    autoIncColumnValue = {};\n    alter?: IAlterQuery;\n\n    constructor(table: ITable) {\n        this.columns = this.setColumn(table.columns);\n        this.name = table.name;\n        this.alter = table.alter || {};\n    }\n\n    setColumn(tableColumns: TColumns) {\n        const columns = [];\n        for (const columnName in tableColumns) {\n            const column: IColumn = tableColumns[columnName] as any;\n            column.name = columnName;\n            if (column.autoIncrement) {\n                this.autoIncColumnValue[columnName] = 0;\n            }\n            if (column.primaryKey) {\n                this.primaryKey = columnName;\n            }\n            column.enableSearch = column.enableSearch == null ? true : column.enableSearch;\n            const existingColumnIndex = this.columns.indexOf(q => q.name === columnName);\n            if (existingColumnIndex < 0) {\n                columns.push(column);\n            }\n            else {\n                const existingColumn = this.columns[existingColumnIndex];\n                Object.assign(existingColumn, column);\n            }\n        }\n        return columns;\n    }\n\n\n}","import { IDBUtil } from \"@/worker/idbutil\";\nimport { promise } from \"@/common\";\n\nexport class MetaHelper {\n    static tableName = \"JsStore_Meta\";\n    static autoIncrementKey(tableName: string, columnName: string) {\n        return `JsStore_${tableName}_${columnName}_Value`;\n    }\n    static dbSchema = `JsStore_DbSchema`;\n\n    static getStore(util: IDBUtil) {\n        if (!util.tx) {\n            util.createTransaction([MetaHelper.tableName]);\n        }\n        return util.objectStore(MetaHelper.tableName);\n    }\n\n    static set(key, value, util: IDBUtil) {\n        const store = MetaHelper.getStore(util);\n        return promise((res, rej) => {\n            const req = store.put({\n                key, value\n            });\n            req.onsuccess = () => {\n                res();\n            };\n            req.onerror = rej;\n        });\n    }\n\n    static get(key, util: IDBUtil) {\n        const store = MetaHelper.getStore(util);\n\n        return promise((res, rej) => {\n            const req = store.get(\n                util.keyRange(key)\n            );\n            req.onsuccess = () => {\n                const result = req.result;\n                res(result && result.value);\n            };\n            req.onerror = rej;\n        });\n    }\n\n    static remove(key, util: IDBUtil) {\n        const store = MetaHelper.getStore(util);\n\n        return promise((res, rej) => {\n            const req = store.delete(\n                util.keyRange(key)\n            );\n            req.onsuccess = () => {\n                res();\n            };\n            req.onerror = rej;\n        });\n    }\n\n    static has(key, util: IDBUtil) {\n        const store = MetaHelper.getStore(util);\n\n        return promise((res, rej) => {\n            const req = store.count(\n                util.keyRange(key)\n            );\n            req.onsuccess = () => {\n                const result = req.result;\n                res(result > 0);\n            };\n            req.onerror = rej;\n        });\n    }\n}","import { IDataBase } from \"@/common\";\nimport { TableMeta } from \"./table_meta\";\nimport { MetaHelper } from \"@worker/meta_helper\";\n\nexport class DbMeta {\n    name: string;\n    version: number;\n    tables: TableMeta[];\n\n    constructor(db: IDataBase) {\n        this.name = db.name;\n        this.version = db.version || 1;\n        db.tables.push({\n            name: MetaHelper.tableName,\n            columns: {\n                key: {\n                    primaryKey: true\n                },\n                value: {\n                    enableSearch: false\n                }\n            },\n        })\n        this.tables = db.tables.map(table => {\n            return new TableMeta(table);\n        });\n    }\n}","export const forObj = (obj: object, cb: (key, value) => void) => {\n    for (const key in obj) {\n        cb(key, obj[key]);\n    }\n}","import { ERROR_TYPE, IError } from \"@/common\";\n\nexport class LogHelper implements IError {\n    type: string;\n    message: string;\n    private info_: any;\n\n    status: boolean;\n\n    log(msg) {\n        if (this.status) {\n            console.log(msg);\n        }\n    }\n\n    constructor(type: string, info?) {\n        this.type = type;\n        this.info_ = info;\n        this.message = this.getMsg_();\n    }\n\n    throw() {\n        throw this.get();\n    }\n\n\n    logError() {\n        console.error(this.get());\n    }\n\n\n\n    get() {\n        return {\n            message: this.message,\n            type: this.type\n        } as IError;\n    }\n\n    private getMsg_() {\n        let errMsg: string;\n        const info = this.info_;\n        const errorHandler = {\n            [ERROR_TYPE.NotArray]() {\n                errMsg = \"Supplied value is not an array\";\n            },\n            [ERROR_TYPE.UndefinedColumn]() {\n                errMsg = \"Column is undefined in Where\";\n            },\n            [ERROR_TYPE.UndefinedValue]() {\n                errMsg = \"Value is undefined in Where\";\n            },\n            [ERROR_TYPE.UndefinedColumnName]() {\n                errMsg = \"Column name is undefined '\" + info['TableName'] + \"'\";\n            },\n            [ERROR_TYPE.UndefinedDbName]() {\n                errMsg = \"Database name is not supplied\";\n            },\n            [ERROR_TYPE.UndefinedColumnValue]() {\n                errMsg = \"Column value is undefined\";\n            },\n            [ERROR_TYPE.NoValueSupplied]() {\n                errMsg = \"No value is supplied\";\n            },\n            [ERROR_TYPE.InvalidOp]() {\n                errMsg = \"Invalid Op Value '\" + info['Op'] + \"'\";\n            },\n            [ERROR_TYPE.ColumnNotExist]() {\n                const column = info['column'];\n                errMsg = info['isOrder'] ?\n                    (\n                        process.env.NODE_ENV !== 'production' && info.isJoin ?\n                            `Column '${column}' in order query is invalid. Please use '<table>.<column>' format for specifying a column in join query.` :\n                            `Column '${column}' in order query does not exist`\n                    ) :\n                    `Column '${column}' does not exist`;\n            },\n            [ERROR_TYPE.NoIndexFound]() {\n                errMsg = \"No index found for column '\" + info['column'] + \"'. Query can not be executed without index.\";\n            },\n            [ERROR_TYPE.NullValue]() {\n                errMsg = \"Null value is not allowed for column '\" + info['ColumnName'] + \"'\";\n            },\n            [ERROR_TYPE.WrongDataType]() {\n                errMsg = \"Supplied value for column '\" + info['column'] +\n                    \"' have wrong data type\";\n            },\n            [ERROR_TYPE.TableNotExist]() {\n                errMsg = \"Table '\" + info['tableName'] + \"' does not exist\";\n            },\n            [ERROR_TYPE.DbNotExist]() {\n                errMsg = `Database with name ${info['dbName']} does not exist`;\n            },\n            [ERROR_TYPE.NotObject]() {\n                errMsg = \"supplied value is not object\";\n            },\n            [ERROR_TYPE.InvalidOp]() {\n                errMsg = \"Invalid Config '\" + info['Config'] + \" '\";\n            },\n            [ERROR_TYPE.DbBlocked]() {\n                errMsg = `database is blocked, cant be deleted right now`;\n            },\n            [ERROR_TYPE.NullValueInWhere]() {\n                errMsg = `Null/undefined is not allowed in where. Column '${info['column']}' has null`;\n            },\n            [ERROR_TYPE.MethodNotExist]() {\n                errMsg = `method '${info}' does not exist.`;\n            },\n            [ERROR_TYPE.IndexedDbNotSupported]() {\n                errMsg = \"Browser does not support indexeddb\";\n            },\n            getInfo() {\n                errMsg = info;\n            },\n            [ERROR_TYPE.InvalidJoinQuery]() {\n                errorHandler.getInfo();\n            },\n            [ERROR_TYPE.ImportScriptsFailed]() {\n                errorHandler.getInfo();\n            },\n            [ERROR_TYPE.InvalidMiddleware]() {\n                errMsg = `No function ${info} is found.`;\n            },\n        };\n        if (process.env.NODE_ENV !== 'production') {\n            Object.assign(errorHandler, {\n                [ERROR_TYPE.InvalidOrderQuery]() {\n                    errorHandler.getInfo();\n                },\n                [ERROR_TYPE.InvalidGroupQuery]() {\n                    errorHandler.getInfo();\n                },\n            })\n        }\n        const errorType = this.type;\n        const method = errorHandler[errorType];\n        if (method) {\n            method();\n        }\n        else {\n            if (!errorType) {\n                this.type = ERROR_TYPE.Unknown\n            }\n            errMsg = this.message;\n        }\n        return errMsg;\n    }\n}","import { DbMeta, TableMeta } from \"@worker/model\";\nimport { IDB_MODE, QUERY_OPTION, promise, forObj, IColumn, IDataBase, InitDbResult } from \"@/common\";\nimport { LogHelper, userDbSchema } from \"@worker/utils\";\nimport { MetaHelper } from \"../meta_helper\";\n\n\nexport class IDBUtil {\n\n    db: DbMeta;\n\n    con: IDBDatabase;\n    tx: IDBTransaction;\n\n    logger = new LogHelper(null);\n\n    emptyTx() {\n        if (!this.tx) return;\n        this.tx.oncomplete = null;\n        this.tx.onabort = null;\n        this.tx.onerror = null;\n        this.tx = null;\n    }\n\n    createTransactionIfNotExist(tables: string[], mode?: IDB_MODE) {\n        if (!this.tx) {\n            this.createTransaction(tables, mode);\n        }\n    }\n\n    createTransaction(tables: string[], mode = IDB_MODE.ReadWrite) {\n        this.tx = this.con.transaction(tables, mode);\n        return promise((res, rej) => {\n            this.tx.oncomplete = res;\n            this.tx.onabort = res;\n            this.tx.onerror = rej;\n        });\n    }\n\n    keyRange(value, op?) {\n        let keyRange: IDBKeyRange;\n        switch (op) {\n            case QUERY_OPTION.Between: keyRange = IDBKeyRange.bound(value.low, value.high, false, false); break;\n            case QUERY_OPTION.GreaterThan: keyRange = IDBKeyRange.lowerBound(value, true); break;\n            case QUERY_OPTION.GreaterThanEqualTo: keyRange = IDBKeyRange.lowerBound(value); break;\n            case QUERY_OPTION.LessThan: keyRange = IDBKeyRange.upperBound(value, true); break;\n            case QUERY_OPTION.LessThanEqualTo: keyRange = IDBKeyRange.upperBound(value); break;\n            default: keyRange = IDBKeyRange.only(value); break;\n        }\n        return keyRange;\n    }\n\n    objectStore(name: string) {\n        return this.tx.objectStore(name);\n    }\n\n    abortTransaction() {\n        if (this.tx) {\n            this.tx.abort();\n        }\n    }\n\n    close() {\n        if (this.con) {\n            this.con.close();\n        }\n        // wait for 100 ms before success\n        return promise(res => {\n            this.con = null;\n            setTimeout(res, 100);\n        });\n    }\n\n    initDb(db: DbMeta) {\n        let isDbCreated = false;\n        const dbVersion = db.version;\n        let oldVersion;\n        const initLogic = (res, rej) => {\n            const dbOpenRequest = indexedDB.open(db.name, dbVersion);\n            dbOpenRequest.onsuccess = () => {\n                this.con = dbOpenRequest.result;\n                this.con.onversionchange = (e: any) => {\n                    // if (e.newVersion === null) { // An attempt is made to delete the db\n                    e.target.close(); // Manually close our connection to the db\n                    // }\n                }\n\n                res({\n                    isCreated: isDbCreated,\n                    oldVersion: oldVersion,\n                    newVersion: dbVersion\n                } as InitDbResult);\n            }\n\n            dbOpenRequest.onerror = (e) => {\n                console.error(\"error\", e);\n                rej(e);\n            };\n\n            dbOpenRequest.onupgradeneeded = (e: IDBVersionChangeEvent) => {\n                oldVersion = e.oldVersion;\n                const target: {\n                    result: IDBDatabase,\n                    transaction: IDBTransaction\n                } = (e as any).target\n                const upgradeConnection = target.result;\n                isDbCreated = true;\n                const transaction = target.transaction;\n                const storeNames = upgradeConnection.objectStoreNames;\n                const createObjectStore = (table: TableMeta) => {\n                    const option: IDBObjectStoreParameters = table.primaryKey ? {\n                        keyPath: table.primaryKey\n                    } : {\n                            autoIncrement: true\n                        }\n\n                    const store = upgradeConnection.createObjectStore(table.name, option);\n                    table.columns.forEach(column => {\n                        addColumn(store, column)\n                    });\n                }\n                const addColumn = (store: IDBObjectStore, column: IColumn) => {\n                    const columnName = column.name;\n                    if (column.enableSearch && !store.indexNames.contains(columnName)) {\n                        const options = column.primaryKey ? { unique: true } : { unique: column.unique };\n                        options['multiEntry'] = column.multiEntry;\n                        const keyPath = column.keyPath == null ? columnName : column.keyPath;\n                        store.createIndex(columnName, keyPath, options);\n                    }\n                }\n                const deleteColumn = (store: IDBObjectStore, table: TableMeta, columnName: string) => {\n                    const index = table.columns.findIndex(q => q.name === columnName);\n                    if (index >= 0) {\n                        table.columns.splice(index, 1);\n                        store.deleteIndex(columnName);\n                    }\n                }\n                db.tables.forEach(table => {\n                    if (!storeNames.contains(table.name)) {\n                        return createObjectStore(table);\n                    }\n                    const store = transaction.objectStore(table.name);\n                    for (let i = oldVersion + 1; i <= dbVersion; i++) {\n                        const alterQuery = table.alter[i];\n                        if (alterQuery) {\n                            if (alterQuery.add) {\n                                const newColumns = table.setColumn(alterQuery.add);\n                                newColumns.forEach(column => {\n                                    addColumn(store, column);\n                                    table.columns.push(column);\n                                })\n                            }\n                            forObj(\n                                alterQuery.drop || {}, ((columnName) => {\n                                    deleteColumn(store, table, columnName);\n                                })\n                            )\n                            forObj(\n                                alterQuery.modify || {}, ((columnName, column: IColumn) => {\n                                    const shouldDelete = column.multiEntry || column.keyPath || column.unique;\n                                    let targetColumn = table.columns.find(q => q.name === columnName);\n                                    const newColumn = Object.assign(targetColumn, column);\n                                    newColumn.name = columnName;\n                                    if (shouldDelete) {\n                                        deleteColumn(store, table, columnName);\n                                        addColumn(store, newColumn);\n                                        table.columns.push(newColumn);\n                                    }\n                                })\n                            )\n                        }\n                    }\n                });\n\n                for (let i = 0, length = storeNames.length; i < length; i++) {\n                    const storeName = storeNames.item(i);\n                    const tableIndex = db.tables.findIndex(qry => qry.name === storeName);\n                    if (tableIndex < 0) {\n                        upgradeConnection.deleteObjectStore(storeName);\n                    }\n                }\n\n            }\n        }\n        return promise<InitDbResult>(initLogic)\n    }\n}","export const promiseAll = <T>(promises: any) => {\n    return Promise.all<T>(promises);\n};","export const promiseReject = (value) => {\n    return Promise.reject(value);\n}","import { LogHelper } from \"./log_helper\";\n\nexport const getError = (e) => {\n    const customError = e instanceof LogHelper;\n    if (customError) {\n        e.logError();\n        return (e as LogHelper).get();\n    }\n    else {\n        let error;\n        if (e.name) {\n            error = new LogHelper(e.name);\n            error.message = e.message;\n        }\n        else {\n            error = new LogHelper((e as any).target.error.name);\n            error.message = (e as any).target.error.message;\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            error.logError();\n        }\n        return error.get();\n    }\n}","import { IDBUtil } from \"@worker/idbutil\";\nimport { IInsertQuery, ISelectQuery, IUpdateQuery } from \"@/common\";\nimport { promiseReject, getErrorFromException } from \"@worker/utils\";\n\nexport class Base {\n\n    get db() {\n        return this.util.db;\n    }\n\n    util: IDBUtil;\n    query: IInsertQuery | ISelectQuery | IUpdateQuery;\n\n    rowAffected = 0;\n    isTxQuery = false;\n    objectStore: IDBObjectStore;\n    tableName: string;\n\n    protected results: any[] = [];\n\n    table(name?: string) {\n        const tableName = name || this.tableName;\n        return this.db.tables.find(q => q.name === tableName)\n    }\n\n    primaryKey(tableName?: string) {\n        const query = this.query as ISelectQuery;\n        if (!query.from && query.store && query.meta) {\n            const primaryKey = query.meta.primaryKey;\n            if (process.env.NODE_ENV !== 'production') {\n                if (primaryKey == null) {\n                    delete query.store;\n                    console.warn(`no primary key found for query - ${JSON.stringify(this.query)}`);\n                }\n            }\n            return primaryKey;\n        }\n        const table = this.table(tableName);\n        if (process.env.NODE_ENV !== 'production') {\n            if (table == null && query.store) {\n                delete query.store;\n                const metaValue = query.meta;\n                if (!metaValue || !metaValue.primaryKey) {\n                    console.warn(`no primary key found for query - ${JSON.stringify(this.query)}. Please supply primary key in meta field.`);\n                }\n            }\n        }\n        return table.primaryKey;\n    }\n\n\n    protected getColumnInfo(columnName: string, tableName?: string) {\n        return this.table(tableName).columns.find(column => column.name === columnName);\n    }\n\n\n\n    onException(ex: DOMException, type?) {\n        console.error(ex);\n        this.util.abortTransaction();\n        return promiseReject(\n            getErrorFromException(ex, type)\n        );\n    }\n}","import { ERROR_TYPE } from \"@/common\"\nimport { getError } from \"./get_error\";\n\nexport const getErrorFromException = (ex, type = ERROR_TYPE.InvalidQuery) => {\n    ex.name = type;\n    return getError(ex);\n}","import { DATA_TYPE } from \"@/common\";\n\nexport const getDataType = (value) => {\n    if (value == null) {\n        return DATA_TYPE.Null;\n    }\n    const type = typeof value;\n    switch (type) {\n        case 'object':\n            if (Array.isArray(value)) {\n                return DATA_TYPE.Array;\n            }\n            if (value instanceof Date) {\n                return DATA_TYPE.DateTime;\n            }\n    }\n    return type;\n}","export const isNull = (value) => {\n    if (value == null) {\n        return true;\n    } else {\n        switch (typeof value) {\n            // case 'string': return value.length === 0;\n            case 'number': return isNaN(value);\n        }\n    }\n    return false;\n};","import { TableMeta } from \"@/worker/model/table_meta\";\nimport { IColumn, TStringAny, ERROR_TYPE, DATA_TYPE, IInsertQuery } from \"@/common\";\nimport { getDataType, LogHelper, isNull } from \"@/worker/utils\";\n\n\nexport class ValuesChecker {\n    table: TableMeta;\n    autoIncrementValue;\n    query: IInsertQuery;\n\n    constructor(table: TableMeta, autoIncValues) {\n        this.table = table;\n        this.autoIncrementValue = autoIncValues;\n    }\n\n    checkAndModifyValues(query: IInsertQuery) {\n        let err: LogHelper;\n        this.query = query;\n        const values = query.values;\n        const ignoreIndexes = [];\n        values.every((item, index) => {\n            err = this.checkAndModifyValue(item);\n            if (query.ignore && err) {\n                ignoreIndexes.push(index);\n                err = null;\n            }\n            return err ? false : true;\n        });\n        ignoreIndexes.forEach(index => {\n            values.splice(index, 1);\n        });\n        return { err, values };\n    }\n\n    private checkAndModifyValue(value) {\n        let error: LogHelper;\n        this.table.columns.every(column => {\n            error = this.checkAndModifyColumnValue_(column, value);\n            return error ? false : true;\n        })\n        return error;\n    }\n\n    private checkNotNullAndDataType_(column: IColumn, value: TStringAny) {\n        // check not null schema\n        if (column.notNull && isNull(value[column.name])) {\n            return this.getError(ERROR_TYPE.NullValue, { ColumnName: column.name });\n        }\n        // check datatype\n        else if (column.dataType && !isNull(value[column.name]) &&\n            getDataType(value[column.name]) !== column.dataType) {\n            return this.getError(ERROR_TYPE.WrongDataType, { column: column.name });\n        }\n    }\n\n    private checkAndModifyColumnValue_(column: IColumn, value: TStringAny) {\n        const columnValue = value[column.name];\n        // check auto increment scheme\n        if (column.autoIncrement) {\n            // if value is null, then create the autoincrement value\n            if (isNull(columnValue)) {\n                value[column.name] = ++this.autoIncrementValue[column.name];\n            }\n            else {\n                if (getDataType(columnValue) === DATA_TYPE.Number) {\n                    // if column value is greater than autoincrement value saved, then make the\n                    // column value as autoIncrement value\n                    if (columnValue > this.autoIncrementValue[column.name]) {\n                        this.autoIncrementValue[column.name] = columnValue;\n                    }\n                }\n            }\n        }\n        // check Default Schema\n        else if (column.default !== undefined && isNull(columnValue)) {\n            value[column.name] = column.default;\n        }\n        const query = this.query;\n        if (query.validation) {\n            return this.checkNotNullAndDataType_(column, value);\n        }\n    }\n\n    private getError(error: string, details: object) {\n        return new LogHelper(error, details);\n    }\n}","import { IColumn, DATA_TYPE, ERROR_TYPE } from \"@/common\";\nimport { LogHelper, isNull, getDataType } from \"@worker/utils\";\nimport { TableMeta } from \"@worker/model\";\n\nexport class SchemaChecker {\n    table: TableMeta;\n    constructor(table: TableMeta) {\n        this.table = table;\n    }\n\n    check(setValue: object, tblName: string) {\n        let log: LogHelper;\n        if (typeof setValue === DATA_TYPE.Object) {\n            if (this.table) {\n                // loop through table column and find data is valid\n                this.table.columns.every((column) => {\n                    if (column.name in setValue) {\n                        log = this.checkByColumn_(column, setValue[column.name]);\n                    }\n                    return log ? false : true;\n                });\n            }\n            else {\n                log = new LogHelper(ERROR_TYPE.TableNotExist, { tableName: tblName });\n            }\n        }\n        else {\n            log = new LogHelper(ERROR_TYPE.NotObject);\n        }\n        return log;\n    }\n\n\n\n    private checkByColumn_(column: IColumn, value) {\n        // check not null schema\n        if (column.notNull === true && isNull(value)) {\n            return new LogHelper(ERROR_TYPE.NullValue, { ColumnName: column.name });\n        }\n\n        // check datatype\n        const type = getDataType(value);\n        const checkFurther = value != null;\n        if (column.dataType && checkFurther) {\n            if (type !== column.dataType && type !== 'object') {\n                return new LogHelper(ERROR_TYPE.WrongDataType, { column: column.name });\n            }\n        }\n\n        // check allowed operators\n        if (checkFurther && type === 'object') {\n            const allowedOp = ['+', '-', '*', '/', '{push}'];\n            for (const prop in value) {\n                if (allowedOp.indexOf(prop) < 0 && column.dataType && type !== column.dataType) {\n                    return new LogHelper(ERROR_TYPE.WrongDataType, { column: column.name });\n                }\n            }\n        }\n    }\n}","import { IInsertQuery, DATA_TYPE, ERROR_TYPE, ISelectQuery, QUERY_OPTION, IUpdateQuery, API } from \"@/common\";\nimport { LogHelper, getDataType } from \"@/worker/utils\";\nimport { DbMeta } from \"../model\";\nimport { ValuesChecker } from \"@worker/executors/insert\";\nimport { SchemaChecker } from \"./update/schema_checker\";\n\nexport class QueryHelper {\n    db: DbMeta;\n\n    constructor(dbSchema: DbMeta) {\n        this.db = dbSchema;\n    }\n\n    validate(api: API, query: IInsertQuery | ISelectQuery | IUpdateQuery) {\n        switch (api) {\n            case API.Select:\n            case API.Remove:\n            case API.Count:\n                return this.checkSelect(query as ISelectQuery);\n            case API.Insert:\n                return this.checkInsertQuery(query as IInsertQuery);\n            case API.Update:\n                return this.checkUpdate(query as IUpdateQuery);\n        }\n    }\n\n    private getTable_(tableName: string) {\n        return this.db.tables.find(q => q.name === tableName);\n    }\n\n    isInsertQryValid(query: IInsertQuery) {\n        const table = this.getTable_(query.into);\n        let log: LogHelper;\n        if (table) {\n            switch (getDataType(query.values)) {\n                case DATA_TYPE.Array:\n                    break;\n                case DATA_TYPE.Null:\n                    log = new LogHelper(ERROR_TYPE.NoValueSupplied);\n                    break;\n                default:\n                    log = new LogHelper(ERROR_TYPE.NotArray);\n            }\n        }\n        else {\n            log = new LogHelper(ERROR_TYPE.TableNotExist, { tableName: query.into });\n        }\n        return {\n            table, log\n        };\n    }\n\n    private checkUpdate(query: IUpdateQuery) {\n        let err = new SchemaChecker(this.getTable_(query.in)).\n            check(query.set, query.in);\n        if (err) return err;\n        if (query.where != null) {\n            err = this.checkForNullInWhere_(query);\n            if (err) return err;\n            this.addGreatAndLessToNotOp_(query as any);\n        }\n    }\n\n    private checkSelect(query: ISelectQuery) {\n        if (!query.store) {\n            const table = this.getTable_(query.from);\n            if (!table) {\n                return new LogHelper(ERROR_TYPE.TableNotExist,\n                    { tableName: query.from }\n                );\n            }\n        }\n\n        if (query.where) {\n            const err = this.checkForNullInWhere_(query);\n            if (err) return err;\n            this.addGreatAndLessToNotOp_(query);\n        }\n    }\n\n    private checkForNullInWhere_(query): LogHelper {\n        for (const columnName in query.where) {\n            if (query.where[columnName] == null) {\n                return new LogHelper(ERROR_TYPE.NullValueInWhere, { column: columnName });\n            }\n        }\n    }\n\n    private addGreatAndLessToNotOp_(query: ISelectQuery) {\n        const whereQuery = query.where;\n        const containsNot = (qry: object, keys: string[]) => {\n            return keys.findIndex(key => qry[key][QUERY_OPTION.NotEqualTo] != null) >= 0;\n        };\n        const addToSingleQry = (qry, keys: string[]) => {\n            let value;\n            keys.forEach((prop) => {\n                value = qry[prop];\n                if (value[QUERY_OPTION.NotEqualTo] != null) {\n                    qry[prop][QUERY_OPTION.GreaterThan] = value[QUERY_OPTION.NotEqualTo];\n                    if (qry[QUERY_OPTION.Or] === undefined) {\n                        qry[QUERY_OPTION.Or] = {};\n                        qry[QUERY_OPTION.Or][prop] = {};\n                    }\n                    else if (qry[QUERY_OPTION.Or][prop] === undefined) {\n                        qry[QUERY_OPTION.Or][prop] = {};\n                    }\n                    qry[QUERY_OPTION.Or][prop][QUERY_OPTION.LessThan] = value[QUERY_OPTION.NotEqualTo];\n                    delete qry[prop][QUERY_OPTION.NotEqualTo];\n                }\n            });\n            return qry;\n        };\n        switch (getDataType(whereQuery)) {\n            case DATA_TYPE.Object:\n                const queryKeys = Object.keys(whereQuery);\n                if (containsNot(whereQuery, queryKeys)) {\n                    if (queryKeys.length === 1) {\n                        query.where = addToSingleQry(whereQuery, queryKeys);\n                    }\n                    else {\n                        const whereTmpQry = [];\n                        queryKeys.forEach((prop) => {\n                            whereTmpQry.push(addToSingleQry({ [prop]: whereQuery[prop] }, [prop]));\n                        });\n                        query.where = whereTmpQry;\n                    }\n                }\n                break;\n            default:\n                const whereTmp = [];\n                (whereQuery as object[]).forEach(qry => {\n                    const qryKeys = Object.keys(qry);\n                    if (containsNot(qry, qryKeys)) {\n                        qry = addToSingleQry(qry, qryKeys);\n                    }\n                    whereTmp.push(qry);\n                });\n                query.where = whereTmp;\n        }\n    }\n\n    private checkInsertQuery(query: IInsertQuery) {\n        const validResult = this.isInsertQryValid(query);\n        let table = validResult.table;\n        const error = validResult.log;\n        if (error) return error;\n        if (query.skipDataCheck) return;\n        const valueCheckerInstance = new ValuesChecker(table, table.autoIncColumnValue);\n        const { values, err } = valueCheckerInstance.checkAndModifyValues(query);\n        query.values = values;\n        return err;\n    }\n}","export * from \"./values_checker\";\nimport { IInsertQuery, promise, promiseAll, API, IDB_MODE } from \"@/common\";\nimport { Base } from \"@worker/executors/base\";\nimport { IDBUtil } from \"@/worker/idbutil\";\nimport { QueryHelper } from \"@worker/executors/query_helper\";\nimport { DbMeta } from \"@/worker/model\";\nimport { promiseReject } from \"@/worker/utils\";\nimport { MetaHelper } from \"@/worker/meta_helper\";\n\nexport class Insert extends Base {\n\n    query: IInsertQuery;\n\n    private valuesAffected_ = [];\n\n    constructor(query: IInsertQuery, util: IDBUtil) {\n        super();\n        if (query.validation == null) {\n            query.validation = true;\n        }\n        this.query = query;\n        this.util = util;\n        this.tableName = query.into;\n    }\n\n    execute(beforeInsert: () => Promise<any>) {\n        const db = this.db;\n        const err = new QueryHelper(db).validate(API.Insert, this.query);\n        if (err) return promiseReject(err);\n\n        return beforeInsert().then(_ => {\n            return this.insertData_(db).then(_ => {\n                return this.query.return ? this.valuesAffected_ : this.rowAffected\n            })\n        }).catch(err => {\n            this.util.abortTransaction();\n            return promiseReject(err);\n        })\n    }\n\n    private insertData_(db: DbMeta) {\n\n        let onInsertData;\n        let addMethod;\n\n        const query = this.query;\n        if (query.return) {\n            onInsertData = (value) => {\n                this.valuesAffected_.push(value);\n            };\n\n        }\n        else {\n            onInsertData = (value) => {\n                ++this.rowAffected;\n            };\n        }\n        addMethod = (() => {\n            const idbMethod = query.upsert ? \"put\" : \"add\";\n            if (query.ignore && !this.isTxQuery) {\n                return (value) => {\n                    const tx = this.util.con.transaction(query.into, IDB_MODE.ReadWrite);\n                    const objectStore = tx.objectStore(query.into);\n                    return objectStore[idbMethod](value);\n                };\n            }\n            if (!this.isTxQuery) {\n                this.util.createTransaction(\n                    [query.into, MetaHelper.tableName],\n                )\n            }\n            this.objectStore = this.util.objectStore(this.tableName);\n            return (value) => {\n                return this.objectStore[idbMethod](value);\n            };\n        })();\n\n        return promiseAll(\n            query.values.map((value) => {\n                return promise((res, rej) => {\n                    const addResult = addMethod(value);\n                    addResult.onerror = (err) => {\n                        if (query.ignore) {\n                            res();\n                        } else {\n                            rej(err);\n                        }\n                    }\n                    addResult.onsuccess = function () {\n                        onInsertData(value);\n                        res();\n                    };\n                });\n            })\n        ).then(() => {\n            return MetaHelper.set(MetaHelper.dbSchema, db, this.util);\n        });\n    }\n}","import { setCrossBrowserIndexedDb } from \"@worker/utils\";\n\nexport const IS_WORKER = typeof (self as any).alert === 'undefined' && typeof ServiceWorkerGlobalScope === 'undefined';\nexport const IS_IDB_SUPPORTED = setCrossBrowserIndexedDb();","export const setCrossBrowserIndexedDb = () => {\n    try {\n        if (!indexedDB) {\n            indexedDB = (self as any).mozIndexedDB ||\n                (self as any).webkitIndexedDB || (self as any).msIndexedDB;\n        }\n        if (indexedDB) {\n            IDBTransaction = IDBTransaction ||\n                (self as any).webkitIDBTransaction || (self as any).msIDBTransaction;\n            (self as any).IDBKeyRange = (self as any).IDBKeyRange ||\n                (self as any).webkitIDBKeyRange || (self as any).msIDBKeyRange;\n        }\n        else {\n            return false;\n        }\n    } catch (ex) {\n        return false;\n    }\n    return true;\n};","export const isArray = (value) => {\n    return Array.isArray(value);\n};","export const getKeys = (value) => {\n    return Object.keys(value);\n};","import { getKeys } from \"./get_keys\"\n\nexport const getLength = (value): number => {\n    return getKeys(value).length;\n}","export const getObjectFirstKey = (value) => {\n    for (const key in value) {\n        return key;\n    }\n};","import { ICaseOption, QUERY_OPTION } from \"@/common\";\n\nexport class ThenEvaluator {\n    private columnName_: string;\n    private value;\n    private caseQuery_: { [columnName: string]: [ICaseOption] };\n    private caseColumnQuery_: ICaseOption[];\n    private length_: number;\n\n    setCaseAndValue(caseQuery: any, value) {\n        this.caseQuery_ = caseQuery;\n        this.setValue(value);\n    }\n\n    setCaseAndColumn(caseQuery: { [columnName: string]: [ICaseOption] }, columnName: string) {\n        this.caseQuery_ = caseQuery;\n        this.setColumn(columnName);\n        return this;\n    }\n\n    setColumn(columnName: string) {\n        this.columnName_ = columnName;\n        this.caseColumnQuery_ = this.caseQuery_[this.columnName_];\n        this.length_ = this.caseColumnQuery_.length;\n        return this;\n    }\n\n    setValue(value) {\n        this.value = value;\n        return this;\n    }\n\n    evaluate() {\n        for (let i = 0; i < this.length_; i++) {\n            if (this.checkCase_(this.caseColumnQuery_[i]) === true) {\n                return this.caseColumnQuery_[i].then;\n            }\n        }\n        const lastThen = this.caseColumnQuery_[this.length_ - 1].then;\n        return lastThen == null ? this.value[this.columnName_] : lastThen;\n    }\n\n    private checkCase_(cond: ICaseOption) {\n        let queryOption;\n        for (queryOption in cond) {\n            switch (queryOption) {\n                case QUERY_OPTION.GreaterThan:\n                    if (this.value[this.columnName_] > cond[queryOption]) {\n                        return true;\n                    } break;\n                case QUERY_OPTION.Equal:\n                    if (this.value[this.columnName_] === cond[queryOption]) {\n                        return true;\n                    } break;\n                case QUERY_OPTION.LessThan:\n                    if (this.value[this.columnName_] < cond[queryOption]) {\n                        return true;\n                    } break;\n                case QUERY_OPTION.GreaterThanEqualTo:\n                    if (this.value[this.columnName_] >= cond[queryOption]) {\n                        return true;\n                    } break;\n                case QUERY_OPTION.LessThanEqualTo:\n                    if (this.value[this.columnName_] <= cond[queryOption]) {\n                        return true;\n                    } break;\n                case QUERY_OPTION.NotEqualTo:\n                    if (this.value[this.columnName_] !== cond[queryOption]) {\n                        return true;\n                    } break;\n                case QUERY_OPTION.Between:\n                    if (this.value[this.columnName_] > cond[queryOption].low && this.value[this.columnName_] < cond[queryOption].high) {\n                        return true;\n                    } break;\n            }\n            return false;\n        }\n    }\n}","import { Select } from \"./\";\nimport { promise } from \"@/common\";\nimport { BaseFetch } from \"../base_fetch\";\n\nexport const getCursorOnSuccess = function (this: Select, simpleFn, limitFn, skipFn, skipAndLimitFn) {\n    if (this.limitAtEnd === false && this.skipAtEnd === false) {\n        if (this.skipRecord) {\n            return this.limitRecord ? skipAndLimitFn : skipFn\n        }\n        if (this.limitRecord) {\n            return limitFn;\n        }\n    }\n    return simpleFn;\n}\n\nexport const executeWhereLogic = function (this: BaseFetch, column, value, op, dir) {\n\n    value = op ? value[op] : value;\n    const cursorRequest = this.objectStore.index(column).openCursor(\n        this.util.keyRange(value, op),\n        dir\n    );\n\n    const onSuccess = getCursorOnSuccess.call(\n        this,\n        executeSimpleForWhere_,\n        executeLimitForWhere_,\n        executeSkipForWhere_,\n        executeSkipAndLimitForWhere_\n    );\n\n    return promise<any>((res, rej) => {\n        cursorRequest.onerror = rej;\n        cursorRequest.onsuccess = onSuccess.call(this, res);\n    })\n\n}\n\nconst executeSkipAndLimitForWhere_ = function (this: Select, onFinish) {\n    let recordSkipped = false;\n    return (e: any) => {\n        const cursor: IDBCursorWithValue = e.target.result;\n        if (cursor) {\n            if (recordSkipped && this.results.length !== this.limitRecord) {\n                if (this.shouldAddValue(cursor)) {\n                    this.pushResult(cursor.value);\n                }\n                cursor.continue();\n            }\n            else {\n                recordSkipped = true;\n                cursor.advance(this.skipRecord);\n            }\n        }\n        else {\n            onFinish();\n        }\n    };\n}\n\nconst executeSkipForWhere_ = function (this: Select, onFinish) {\n    let recordSkipped = false;\n    return (e: any) => {\n        const cursor = e.target.result;\n        if (cursor) {\n            if (recordSkipped) {\n                if (this.shouldAddValue(cursor)) {\n                    this.pushResult(cursor.value);\n                }\n                cursor.continue();\n            }\n            else {\n                recordSkipped = true;\n                cursor.advance(this.skipRecord);\n            }\n        }\n        else {\n            onFinish();\n        }\n    };\n}\n\nexport const executeLimitForWhere_ = function (this: Select, onFinish) {\n    return (e: any) => {\n        const cursor = e.target.result;\n        if (cursor && this.results.length !== this.limitRecord) {\n            if (this.shouldAddValue(cursor)) {\n                this.pushResult(cursor.value);\n            }\n            cursor.continue();\n        }\n        else {\n            onFinish();\n        }\n    };\n\n}\n\nexport const executeSimpleForWhere_ = function (this: Select, onFinish) {\n    return (e: any) => {\n        const cursor: IDBCursorWithValue = e.target.result;\n        if (cursor) {\n            if (this.shouldAddValue(cursor)) {\n                this.pushResult(cursor.value);\n            }\n            cursor.continue();\n        }\n        else {\n            onFinish();\n        }\n    };\n}","import { Select } from \"./index\";\nimport { LogHelper, promiseReject } from \"@/worker/utils\";\nimport { ERROR_TYPE, IOrderQuery, promise, promiseResolve } from \"@/common\";\nimport { getCursorOnSuccess } from \"./where\";\n\nexport const executeWhereUndefinedLogic = function (this: Select) {\n    let cursorRequest: IDBRequest;\n    const query = this.query;\n    const store = query.store;\n    if (store) {\n        this.results = store as any[];\n        this.setLimitAndSkipEvaluationAtEnd_();\n        return promiseResolve();\n    }\n    const orderQuery = query.order;\n    const objectStore = this.objectStore;\n    if (orderQuery && (orderQuery as IOrderQuery).idbSorting !== false && (orderQuery as IOrderQuery).by) {\n        if (objectStore.indexNames.contains((orderQuery as IOrderQuery).by as string)) {\n            const orderType: IDBCursorDirection = (orderQuery as IOrderQuery).type &&\n                (orderQuery as IOrderQuery).type.toLowerCase() === 'desc' ? 'prev' : 'next';\n            this.sorted = true;\n            cursorRequest = objectStore.index((orderQuery as IOrderQuery).by as string).\n                openCursor(null, orderType);\n        }\n        else {\n            return promiseReject(\n                new LogHelper(\n                    ERROR_TYPE.ColumnNotExist,\n                    { column: (orderQuery as IOrderQuery).by, isOrder: true }\n                )\n            );\n        }\n    }\n    else {\n        cursorRequest = objectStore.openCursor();\n    }\n\n    const onSuccess = getCursorOnSuccess.call(\n        this,\n        executeSimple,\n        executeLimit,\n        executeSkip,\n        executeSkipAndLimit\n    );\n\n    return promise<void>((res, rej) => {\n        cursorRequest.onerror = rej;\n        cursorRequest.onsuccess = onSuccess.call(this, res);\n    });\n}\n\nconst executeSkipAndLimit = function (this: Select, onFinished) {\n    let recordSkipped = false,\n        cursor: IDBCursorWithValue;\n    return (e) => {\n        cursor = (e as any).target.result;\n        if (cursor) {\n            if (recordSkipped && this.results.length !== this.limitRecord) {\n                this.pushResult(cursor.value);\n                cursor.continue();\n            }\n            else {\n                recordSkipped = true;\n                cursor.advance(this.skipRecord);\n            }\n        } else {\n            onFinished();\n        }\n    };\n}\n\nconst executeSkip = function (this: Select, onFinished) {\n    let recordSkipped = false,\n        cursor;\n    return (e: any) => {\n        cursor = e.target.result;\n        if (cursor) {\n            if (recordSkipped) {\n                this.pushResult(cursor.value);\n                cursor.continue();\n            }\n            else {\n                recordSkipped = true;\n                cursor.advance(this.skipRecord);\n            }\n        } else {\n            onFinished();\n        }\n    };\n}\n\nconst executeSimple = function (this: Select, onFinished) {\n    let cursor;\n    return (e: any) => {\n        cursor = e.target.result;\n        if (cursor) {\n            this.pushResult(cursor.value);\n            (cursor as any).continue();\n        }\n        else {\n            onFinished();\n        }\n    };\n}\n\nconst executeLimit = function (this: Select, onFinished) {\n    let cursor;\n    return (e: any) => {\n        cursor = e.target.result;\n        if (cursor && this.results.length !== this.limitRecord) {\n            this.pushResult(cursor.value);\n            cursor.continue();\n        } else {\n            onFinished();\n        }\n    };\n}\n","export const removeSpace = (value: string) => {\n    return value.replace(/\\s/g, '');\n};","import { Select } from \"./\";\nimport { removeSpace, getDataType, LogHelper } from \"@/worker/utils\";\nimport { ERROR_TYPE, DATA_TYPE, ICaseOption, IColumn, IOrderQuery } from \"@/common\";\n\nexport const processGroupDistinctAggr = function (this: Select) {\n    const query = this.query;\n    if (query.distinct) {\n        const groupBy = [];\n        const result = this.results[0];\n        for (const key in result) {\n            groupBy.push(key);\n        }\n        const primaryKey = this.primaryKey();\n        const index = groupBy.indexOf(primaryKey);\n        groupBy.splice(index, 1);\n        query.groupBy = groupBy.length > 0 ? groupBy : null;\n    }\n    if (query.groupBy) {\n        if (query.aggregate) {\n            this.executeAggregateGroupBy();\n        }\n        else {\n            this.processGroupBy();\n        }\n    }\n    else if (query.aggregate) {\n        this.processAggregateQry();\n    }\n};\n\nconst getOrderColumnInfo = function (this: Select, orderColumn: string) {\n    let column: IColumn;\n    if (!this.query.store) {\n        if (this.query.join == null) {\n            column = this.getColumnInfo(orderColumn);\n        }\n        else {\n            const splittedByDot = removeSpace(orderColumn).split(\".\");\n            const joinOrderColumn = splittedByDot[1];\n            if (process.env.NODE_ENV !== 'production' && joinOrderColumn == null) {\n                new LogHelper(ERROR_TYPE.ColumnNotExist,\n                    { column: orderColumn, isOrder: true, isJoin: true }\n                ).throw()\n            }\n            column = this.getColumnInfo(joinOrderColumn, splittedByDot[0]);\n        }\n    }\n    if (column == null) {\n        const valueFromFirstColumn = this.results[0][orderColumn];\n        if (valueFromFirstColumn) {\n            return {\n                dataType: getDataType(valueFromFirstColumn),\n                name: orderColumn\n            } as IColumn;\n        }\n        throw new LogHelper(ERROR_TYPE.ColumnNotExist,\n            { column: orderColumn, isOrder: true }\n        )\n\n    }\n    return column;\n}\n\nconst compareStringInDesc_ = (a: string, b: string) => {\n    return b.localeCompare(a);\n}\n\nconst compareStringinAsc_ = (a: string, b: string) => {\n    return a.localeCompare(b);\n}\n\nconst compareDefaultInDesc_ = (a: string, b) => {\n    return new String(b).localeCompare(a);\n}\n\nconst compareDefaultinAsc_ = (a, b: string) => {\n    return new String(a).localeCompare(b);\n}\n\nconst compareNumberInDesc_ = (a: number, b: number) => {\n    return b - a;\n}\n\nconst compareNumberinAsc_ = (a: number, b: number) => {\n    return a - b;\n}\n\nconst compareDateInDesc_ = (a: Date, b: Date) => {\n    return b.getTime() - a.getTime();\n}\n\nconst compareDateInAsc_ = (a: Date, b: Date) => {\n    return a.getTime() - b.getTime();\n}\n\nconst getValueComparer_ = (column: IColumn, order: IOrderQuery): (a, b) => number => {\n    switch (column.dataType) {\n        case DATA_TYPE.String:\n            return order.type === 'asc' ? compareStringinAsc_ : compareStringInDesc_;\n        case DATA_TYPE.Number:\n            return order.type === 'asc' ? compareNumberinAsc_ : compareNumberInDesc_;\n        case DATA_TYPE.DateTime:\n            return order.type === 'asc' ? compareDateInAsc_ : compareDateInDesc_;\n        default:\n            return order.type === 'asc' ? compareDefaultinAsc_ : compareDefaultInDesc_;\n    }\n\n}\n\nconst orderBy_ = function (this: Select, order: IOrderQuery) {\n    order.type = getOrderType_(order.type);\n    let orderColumn = order.by;\n    const thenEvaluator = this.thenEvaluator;\n    if (orderColumn != null && typeof orderColumn === DATA_TYPE.Object) {\n        const caseQuery = orderColumn as { [columnName: string]: [ICaseOption] };\n        const getValInAscDesc = (stringComparer, numberComparer) => {\n            return (value1, value2) => {\n                for (const columnName in caseQuery) {\n                    thenEvaluator.setCaseAndValue(caseQuery, value1);\n                    const column1 = thenEvaluator.setColumn(columnName).evaluate();\n                    thenEvaluator.setCaseAndValue(caseQuery, value2);\n                    const column2 = thenEvaluator.setColumn(columnName).evaluate();\n                    switch (typeof value1[column1]) {\n                        case DATA_TYPE.String:\n                            return stringComparer(value1[column1], value2[column2]);\n                        default:\n                            return numberComparer(value1[column1], value2[column2]);\n                    }\n                }\n            }\n        };\n        let sortMethod = order.type === 'asc' ?\n            getValInAscDesc(compareStringinAsc_, compareNumberinAsc_) :\n            getValInAscDesc(compareStringInDesc_, compareNumberInDesc_);\n\n        this.results.sort(sortMethod);\n    }\n    else {\n        const columnInfo = getOrderColumnInfo.call(this, orderColumn as string);\n        if (columnInfo != null) {\n            const orderMethod = getValueComparer_(columnInfo, order);\n            orderColumn = columnInfo.name;\n            if (order.case == null) {\n                this.results.sort((a, b) => {\n                    return orderMethod(a[orderColumn as string], b[orderColumn as string]);\n                });\n            }\n            else {\n                thenEvaluator.setCaseAndColumn({ [orderColumn as string]: order.case }, orderColumn as string);\n                this.results.sort((a, b) => {\n                    return orderMethod(\n                        thenEvaluator.setValue(a).evaluate(),\n                        thenEvaluator.setValue(b).evaluate()\n                    );\n                });\n            }\n        }\n    }\n\n}\n\nconst getOrderType_ = (type: string) => {\n    return type == null ? 'asc' : type.toLowerCase();\n}\n\nexport const processOrderBy = function (this: Select) {\n    const order = this.query.order;\n    if (order && this.results.length > 0 && !this.sorted) {\n        const orderQueryType = getDataType(order);\n        if (orderQueryType === DATA_TYPE.Object) {\n            orderBy_.call(this, order);\n        }\n        else if (orderQueryType === DATA_TYPE.Array) {\n            orderBy_.call(this, order[0]);\n            for (let i = 1, length = (order as any).length; i < length; i++) {\n                const prevOrderQueryBy = order[i - 1].by;\n                const currentOrderQuery: IOrderQuery = order[i];\n                let currentorderQueryBy = currentOrderQuery.by;\n                const orderColumnDetail = getOrderColumnInfo.call(this, currentorderQueryBy as string);\n                if (orderColumnDetail != null) {\n                    currentorderQueryBy = orderColumnDetail.name;\n                    currentOrderQuery.type = getOrderType_(currentOrderQuery.type);\n                    const orderMethod = getValueComparer_(orderColumnDetail, currentOrderQuery);\n                    this.results.sort((a, b) => {\n                        if (a[prevOrderQueryBy] === b[prevOrderQueryBy]) {\n                            return orderMethod(\n                                a[currentorderQueryBy as string],\n                                b[currentorderQueryBy as string]\n                            );\n                        }\n                        return 0;\n                    });\n                }\n            }\n        }\n    }\n}\n\nexport const processAggregateQry = function (this: Select) {\n    const datas = this.results;\n    const datasLength = datas.length;\n    const results = {};\n    let columnToAggregate;\n\n    const getCount = () => {\n        let result = 0;\n        for (const i in datas) {\n            result += datas[i][columnToAggregate] ? 1 : 0;\n        }\n        return result;\n    };\n    const getMax = () => {\n        let result = 0;\n        for (const i in datas) {\n            result = result > datas[i][columnToAggregate] ?\n                result : datas[i][columnToAggregate];\n        }\n        return result;\n    };\n    const getMin = () => {\n        let result = Infinity, value = Infinity;\n        for (const i in datas) {\n            value = datas[i][columnToAggregate] ?\n                datas[i][columnToAggregate] : Infinity;\n            result = result < value ? result : value;\n        }\n        return result;\n    };\n    const getSum = () => {\n        let result = 0;\n        for (const i in datas) {\n            result += datas[i][columnToAggregate];\n        }\n        return result;\n    };\n    const getAvg = () => {\n        return getSum() / datasLength;\n    };\n    const aggregateQry = this.query.aggregate;\n    for (const prop in aggregateQry) {\n        const aggregateColumn = aggregateQry[prop];\n        const aggregateValType = getDataType(aggregateColumn);\n        let aggregateCalculator;\n        switch (prop) {\n            case 'count':\n                aggregateCalculator = getCount; break;\n            case 'max':\n                aggregateCalculator = getMax; break;\n            case 'min':\n                aggregateCalculator = getMin; break;\n            case 'sum':\n                aggregateCalculator = getSum; break;\n            case 'avg':\n                aggregateCalculator = getAvg;\n        }\n        switch (aggregateValType) {\n            case DATA_TYPE.String:\n                columnToAggregate = aggregateColumn;\n                results[`${prop}(${columnToAggregate})`] = aggregateCalculator();\n                break;\n            case DATA_TYPE.Array:\n                for (const key in aggregateColumn) {\n                    columnToAggregate = aggregateColumn[key];\n                    results[`${prop}(${columnToAggregate})`] = aggregateCalculator();\n                }\n        }\n    }\n\n    // add results to the first index of result\n    for (const prop in results) {\n        datas[0][prop] = results[prop];\n    }\n    this.results = [datas[0]];\n}","import { OCCURENCE } from \"@/common\";\n\nexport const getRegexFromLikeExpression = (likeExpression: string) => {\n    const filterValues = likeExpression.split('%');\n    let filterValue: string;\n    let occurence: OCCURENCE;\n    if (filterValues[1]) {\n        filterValue = filterValues[1];\n        occurence = filterValues.length > 2 ? OCCURENCE.Any : OCCURENCE.Last;\n    }\n    else {\n        filterValue = filterValues[0];\n        occurence = OCCURENCE.First;\n    }\n    switch (occurence) {\n        case OCCURENCE.First:\n            return new RegExp(`^${filterValue}`, 'i');\n        case OCCURENCE.Last:\n            return new RegExp(`${filterValue}$`, 'i');\n        default:\n            return new RegExp(`${filterValue}`, 'i');\n    }\n}","import { getDataType } from \"./get_data_type\";\n\nconst isObject = (value) => {\n    return getDataType(value) === 'object' && !(value instanceof RegExp);\n};\n\nexport const clone = (obj) => {\n    if (isObject(obj)) {\n        const copy = {};\n        for (const i in obj) {\n            copy[i] = obj[i] != null && isObject(obj[i]) ? clone(obj[i]) : obj[i];\n        }\n        return copy;\n    }\n    return obj;\n};","import { getDataType } from \"./get_data_type\"\nimport { QUERY_OPTION, DATA_TYPE } from \"@/common\";\nimport { isArray } from \"./is_array\";\n\nexport const compare = (value, compareValue, symbol?) => {\n    const type1 = getDataType(value);\n    const type2 = getDataType(compareValue);\n\n    if (type1 !== type2) return false;\n    if (type1 === DATA_TYPE.DateTime) {\n        value = value.getTime();\n        compareValue = compareValue.getTime();\n    }\n    switch (symbol) {\n        // greater than\n        case QUERY_OPTION.GreaterThan:\n            return value > compareValue;\n        // less than\n        case QUERY_OPTION.LessThan:\n            return value < compareValue;\n        // less than equal\n        case QUERY_OPTION.LessThanEqualTo:\n            return value <= compareValue;\n        // greather than equal\n        case QUERY_OPTION.GreaterThanEqualTo:\n            return value >= compareValue;\n        // Not equal to\n        case QUERY_OPTION.NotEqualTo:\n            return value !== compareValue;\n        default:\n            if (type1 === 'array') {\n                if (value.length !== compareValue.length) return false;\n                let status;\n                value.every((item, index) => {\n                    status = item === compareValue[index];\n                    return status;\n                });\n                return status;\n            }\n            return value === compareValue;\n    }\n}","import { QUERY_OPTION } from \"@/common\";\nimport { getDataType, clone, compare, getRegexFromLikeExpression, isArray } from \"@worker/utils\";\n\n/**\n * For matching the different column value existance for where option\n * \n * @export\n * @class WhereChecker\n */\nexport class WhereChecker {\n  where: object;\n  checkFlag: boolean;\n\n  constructor(where: object, checkFlag: boolean) {\n    this.where = clone(where);\n    this.checkFlag = checkFlag;\n  }\n\n  remove(props: string[]) {\n    const last = props.pop();\n    const value = props.reduce((prev, curr) => prev && prev[curr], this.where);\n    delete value[last];\n  }\n\n  check(rowValue) {\n    let status = true;\n    if (!this.checkFlag) return status;\n    const where = this.where;\n    for (let columnName in where) {\n      if (!status) {\n        return status;\n      }\n      const whereColumnValue = where[columnName];\n      const columnValue = rowValue[columnName];\n      const isArrayColumnValue = isArray(columnValue);\n      const isArrayWhereColumnValue = isArray(whereColumnValue);\n      const executeCompare = (executor: Function) => {\n        if (isArrayColumnValue && !isArrayWhereColumnValue) {\n          columnValue.every(q => {\n            status = executor(q);\n            return !status;\n          })\n        }\n        else {\n          status = executor(columnValue);\n        }\n        return\n      }\n\n      if (getDataType(whereColumnValue) === \"object\") {\n        for (const key in whereColumnValue) {\n          if (!status) {\n            return status;\n          }\n          switch (key) {\n            case QUERY_OPTION.In:\n              executeCompare((compareValue) => {\n                return this.checkIn(whereColumnValue[QUERY_OPTION.In], compareValue);\n              })\n              break;\n            case QUERY_OPTION.Like:\n              executeCompare((compareValue) => {\n                return this.checkLike_(columnName, compareValue);\n              })\n              break;\n            case QUERY_OPTION.Regex:\n              executeCompare((compareValue) => {\n                return this.checkRegex(columnName, compareValue);\n              })\n              break;\n            case QUERY_OPTION.Between:\n            case QUERY_OPTION.GreaterThan:\n            case QUERY_OPTION.LessThan:\n            case QUERY_OPTION.GreaterThanEqualTo:\n            case QUERY_OPTION.LessThanEqualTo:\n            case QUERY_OPTION.NotEqualTo:\n              executeCompare((compareValue) => {\n                return this.checkComparisionOp_(columnName, compareValue, key);\n              })\n              break;\n            default:\n              status = false;\n          }\n        }\n      }\n      else {\n        executeCompare((storedValue) => {\n          return compare(whereColumnValue, storedValue);\n        });\n      }\n    }\n    return status;\n  }\n\n  private checkIn(whereColumnValue: any[], value) {\n    return whereColumnValue.find(q => compare(q, value)) != null;\n  }\n\n  private checkLike_(column, value) {\n    return getRegexFromLikeExpression(this.where[column][QUERY_OPTION.Like]).test(value);\n  }\n\n  private checkRegex(column, value) {\n    return this.where[column][QUERY_OPTION.Regex].test(value);\n  }\n\n  private checkComparisionOp_(column, value, symbol) {\n    const compareValue = this.where[column][symbol];\n    if (symbol != QUERY_OPTION.Between) {\n      return compare(value, compareValue, symbol);\n    }\n    return compare(value, compareValue.low, '>=') &&\n      compare(value, compareValue.high, '<=');\n  }\n}","import { Base } from \"./base\";\nimport { ISelectQuery, QUERY_OPTION, ERROR_TYPE } from \"@/common\";\nimport { getRegexFromLikeExpression, promiseReject } from \"@worker/utils\";\nimport { LogHelper, getObjectFirstKey, getDataType, getLength } from \"@worker/utils\";\nimport { WhereChecker } from \"./where_checker\";\nimport { executeWhereLogic } from \"./select/where\";\nimport { executeInLogic } from \"./select/in\";\nimport { executeRegexLogic } from \"./select/regex\";\n\nexport class BaseFetch extends Base {\n    query: ISelectQuery;\n    whereChecker: WhereChecker;\n    executeWhereLogic: typeof executeWhereLogic;\n    skipRecord;\n    limitRecord;\n    limitAtEnd = false;\n    skipAtEnd = false;\n    executeInLogic: typeof executeInLogic;\n    executeRegexLogic: typeof executeRegexLogic;\n\n    resultCount: number;\n\n    protected shouldAddValue: (value) => boolean;\n    protected goToWhereLogic() {\n        const query = this.query as ISelectQuery;\n        const whereQuery = query.where;\n        let firstColumn = (() => {\n            for (const key in whereQuery) {\n                if (this.objectStore.indexNames.contains(key)) {\n                    return key;\n                }\n            }\n        })();\n        if (firstColumn == null) {\n            firstColumn = getObjectFirstKey(whereQuery);\n            if (!query.store) {\n                return promiseReject(\n                    new LogHelper(ERROR_TYPE.NoIndexFound, { column: firstColumn })\n                );\n            }\n        }\n        const value = whereQuery[firstColumn];\n        if (getDataType(value) === 'object') {\n            const checkFlag = getLength(value) > 1 ||\n                getLength(whereQuery) > 1\n\n            this.whereChecker = new WhereChecker(whereQuery, checkFlag);\n            const key = getObjectFirstKey(value);\n            this.whereChecker.remove([firstColumn, key]);\n            switch (key) {\n                case QUERY_OPTION.Like: {\n                    const regexVal = getRegexFromLikeExpression(value[QUERY_OPTION.Like]);\n                    return this.executeRegexLogic(firstColumn, regexVal);\n                }\n                case QUERY_OPTION.Regex:\n                    return this.executeRegexLogic(firstColumn, value[QUERY_OPTION.Regex]);\n                case QUERY_OPTION.In:\n                    return this.executeInLogic(\n                        firstColumn, value[QUERY_OPTION.In]\n                    );\n                case QUERY_OPTION.Between:\n                case QUERY_OPTION.GreaterThan:\n                case QUERY_OPTION.LessThan:\n                case QUERY_OPTION.GreaterThanEqualTo:\n                case QUERY_OPTION.LessThanEqualTo:\n                    return this.executeWhereLogic(firstColumn, value, key, \"next\");\n                case QUERY_OPTION.Aggregate: break;\n                default:\n                    return this.executeWhereLogic(firstColumn, value, null, \"next\");\n            }\n        }\n        else {\n            const checkFlag = getLength(whereQuery) > 1;\n            this.whereChecker = new WhereChecker(whereQuery, checkFlag);\n            this.whereChecker.remove([firstColumn]);\n            return this.executeWhereLogic(firstColumn, value, null, \"next\");\n        }\n    }\n\n}","import { BaseFetch } from \"../base_fetch\";\nimport { Select } from \".\";\nimport { promise } from \"@/common\";\nimport { executeLimitForWhere_, executeSimpleForWhere_, getCursorOnSuccess } from \"./where\";\n\n\nexport const executeRegexLogic = function (this: BaseFetch, column, exp: RegExp) {\n\n    let skip = this.skipRecord;\n    const skipOrPush = (val) => {\n        if (skip === 0) {\n            (this as Select)['pushResult'](val);\n        }\n        else {\n            --skip;\n        }\n    };\n    this.shouldAddValue = (cursor) => {\n        return exp.test(cursor.key) &&\n            this.whereChecker.check(cursor.value);\n    };\n\n    const cursorRequest = this.objectStore.index(column).openCursor();\n\n    const onSuccess = getCursorOnSuccess.call(\n        this,\n        executeSimpleForWhere_,\n        executeLimitForWhere_,\n        executeSkipForWhere_,\n        executeSkipAndLimitForWhere_\n    );\n\n    return promise<any>((res, rej) => {\n        cursorRequest.onerror = rej;\n        cursorRequest.onsuccess = onSuccess.call(this, res, skipOrPush);\n    })\n\n}\n\nexport const executeSkipAndLimitForWhere_ = function (this: Select, onFinish, skipOrPush) {\n    return (e: any) => {\n        const cursor = e.target.result;\n        if (this.results.length !== this.limitRecord && cursor) {\n            if (this.shouldAddValue(cursor)) {\n                skipOrPush(cursor.value);\n            }\n            cursor.continue();\n        } else {\n            onFinish();\n        }\n    };\n}\n\nexport const executeSkipForWhere_ = function (this: Select, onFinish, skipOrPush) {\n    return (e: any) => {\n        const cursor = e.target.result;\n        if (cursor) {\n            if (this.shouldAddValue(cursor)) {\n                skipOrPush((cursor.value));\n            }\n            cursor.continue();\n        } else {\n            onFinish();\n        }\n    };\n}\n\n\n\n\n","import { Select } from \"./\";\nimport { IJoinQuery, DATA_TYPE, ERROR_TYPE, ISelectQuery, IErrorType } from \"@/common\";\nimport { getDataType, LogHelper, removeSpace, promiseReject, getKeys, getLength } from \"@/worker/utils\";\nimport { WhereChecker } from \"@executors/where_checker\";\n\n\nexport const executeJoinQuery = function (this: Select) {\n    return new Join(this).execute();\n}\n\ninterface JoinQueryWithInfo extends IJoinQuery {\n    joinTableInfo: JoinTableInfo\n}\n\nclass Join {\n\n    private joinQueryStack_: JoinQueryWithInfo[] = [];\n    private currentQueryStackIndex_ = 0;\n    tablesFetched = [];\n    results = [];\n\n    select: Select;\n    constructor(select: Select) {\n        this.select = select;\n    }\n\n    get query() {\n        return this.select.query;\n    }\n\n    getTable(name: string) {\n        return this.select.table(name);\n    }\n\n    private executeSelect(query: ISelectQuery) {\n        return new Select(query, this.select.util).\n            execute();\n    }\n\n    execute() {\n        const query = this.query;\n        this.joinQueryStack_ = getDataType(query.join) === DATA_TYPE.Object ?\n            [query.join as JoinQueryWithInfo] : query.join as JoinQueryWithInfo[];\n        // get the data for first table\n        const tableName = query.from;\n        const tablesToFetch = [];\n        if (tableName) {\n            tablesToFetch.push(tableName);\n        }\n        const joinQueryStack = this.joinQueryStack_;\n        for (let i = 0, length = joinQueryStack.length; i < length; i++) {\n            const item = joinQueryStack[i];\n            let jointblInfo = this.getJoinTableInfo_(item.on);\n            // table 1 is fetched & table2 needs to be fetched for join\n            if (item.with === jointblInfo.table1.table) {\n                jointblInfo = {\n                    table1: jointblInfo.table2,\n                    table2: jointblInfo.table1\n                };\n            }\n\n            const err = this.checkJoinQuery_(jointblInfo, item);\n            if (err) {\n                return promiseReject(err);\n            }\n            joinQueryStack[i].joinTableInfo = jointblInfo;\n            if (item.with) {\n                tablesToFetch.push(item.with)\n            }\n        }\n\n        if (!this.select.isTxQuery && tablesToFetch.length > 0) {\n            this.select.util.createTransaction(tablesToFetch);\n        }\n\n        const whereQuery = query.where;\n        // remove column which not exist in first table\n        if (whereQuery && !query.store) {\n            const table = this.getTable(tableName);\n            const removeJoinColumn = (whereQryParam) => {\n                let whereQryAfterJoin;\n                if (Array.isArray(whereQryParam)) {\n                    whereQryAfterJoin = [];\n                    whereQryParam = whereQryParam.filter((qry) => {\n                        const result = removeJoinColumn(qry);\n                        if (Object.keys(result.whereQryAfterJoin).length > 0) {\n                            whereQryAfterJoin.push(result.whereQryAfterJoin);\n                        }\n                        return !result.isWhereEmpty\n                    });\n                }\n                else {\n                    whereQryAfterJoin = {};\n                    for (const column in whereQryParam) {\n                        switch (column) {\n                            case \"or\":\n                                const filteredOr = {};\n                                const whereQryOr = whereQryParam[column];\n                                for (const orColumn in whereQryOr) {\n                                    const columnInTable = table.columns.find(q => q.name === orColumn);\n                                    if (!columnInTable) {\n                                        filteredOr[orColumn] = whereQryOr[orColumn];\n                                    }\n                                }\n                                if (getLength(filteredOr) > 0) {\n                                    whereQryAfterJoin['or'] = filteredOr;\n                                    for (const orColumn in filteredOr) {\n                                        delete whereQryOr[orColumn];\n                                    }\n                                }\n                                break;\n                            default:\n                                const columnInTable = table.columns.find(q => q.name === column);\n                                if (!columnInTable) {\n                                    whereQryAfterJoin[column] = whereQuery[column];\n                                }\n                        }\n                    }\n                    for (const column in whereQryAfterJoin) {\n                        delete whereQryParam[column];\n                    }\n                }\n                return {\n                    isWhereEmpty: getLength(whereQryParam) === 0,\n                    whereQryAfterJoin,\n                    whereQueryModified: whereQryParam\n                }\n            }\n            const removeJoinColumnResult = removeJoinColumn(whereQuery);\n            const whereQryAfterJoin = removeJoinColumnResult.whereQryAfterJoin;\n            query.where = removeJoinColumnResult.whereQueryModified;\n            if (removeJoinColumnResult.isWhereEmpty) {\n                delete query.where;\n            }\n            const joinQuery = this.joinQueryStack_[0];\n            Object.assign(joinQuery['whereJoin'], whereQryAfterJoin);\n        }\n\n        return this.executeSelect({\n            from: tableName,\n            where: query.where,\n            case: query.case,\n            flatten: query.flatten,\n            store: query.store,\n            meta: query.meta\n        }).then(results => {\n            this.results = results.map((item) => {\n                return {\n                    [this.currentQueryStackIndex_]: item\n                };\n            });\n            this.tablesFetched.push(\n                joinQueryStack[0].joinTableInfo.table1.table\n            );\n            return this.startExecutingJoinLogic_();\n        });\n    }\n\n    private onJoinQueryFinished_() {\n        if (this.results.length === 0) return;\n        const selectApi = this.select;\n        try {\n            let results = [];\n            const tables = getKeys(this.results[0]);\n            const tablesLength = tables.length;\n            this.results.forEach((result) => {\n                let data = result[\"0\"]; // first table data\n                for (let i = 1; i < tablesLength; i++) {\n                    data = { ...data, ...result[i] };\n                }\n                results.push(data);\n            });\n            selectApi['results'] = results;\n            selectApi.setLimitAndSkipEvaluationAtEnd_();\n            selectApi.query.flatten = null;\n            if (process.env.NODE_ENV !== 'production') {\n                try {\n                    selectApi.processOrderBy();\n                }\n                catch (ex) {\n                    return promiseReject(\n                        new LogHelper((ERROR_TYPE as IErrorType).InvalidOrderQuery, ex.message)\n                    );\n                }\n            }\n            else {\n                selectApi.processOrderBy();\n            }\n        }\n        catch (ex) {\n            return promiseReject(\n                new LogHelper(ERROR_TYPE.InvalidJoinQuery, ex.message)\n            );\n        }\n    }\n\n    private startExecutingJoinLogic_() {\n        const joinQuery = this.joinQueryStack_[this.currentQueryStackIndex_];\n        if (joinQuery) {\n            try {\n                let jointblInfo = joinQuery.joinTableInfo;\n                return this.executeSelect({\n                    from: joinQuery.with,\n                    where: joinQuery.where,\n                    case: joinQuery.case,\n                    flatten: joinQuery.flatten,\n                    store: joinQuery.store,\n                    meta: joinQuery.meta\n                }).then(results => {\n                    this.jointables(joinQuery, jointblInfo, results);\n                    this.tablesFetched.push(jointblInfo.table2.table);\n                    ++this.currentQueryStackIndex_;\n                    return this.startExecutingJoinLogic_();\n                });\n            }\n            catch (ex) {\n                return promiseReject(\n                    new LogHelper(ERROR_TYPE.InvalidJoinQuery, ex.message)\n                );\n            }\n        }\n        else {\n            return this.onJoinQueryFinished_();\n        }\n    }\n\n    private jointables(joinQuery: JoinQueryWithInfo, jointblInfo: JoinTableInfo, secondtableData: any[]) {\n        const joinType = joinQuery.type;\n        const output = [];\n        const column1 = jointblInfo.table1.column;\n        const column2 = jointblInfo.table2.column;\n        const table1Index = this.tablesFetched.indexOf(jointblInfo.table1.table);\n        const table2Index = this.currentQueryStackIndex_ + 1;\n        const asQuery = joinQuery.as;\n        const mapWithAlias = asQuery ? (value: object) => {\n            for (const key in asQuery) {\n                const asValue = asQuery[key];\n                if (value[asValue] === undefined) {\n                    value[asValue] = value[key];\n                    delete value[key];\n                }\n            }\n            return value;\n        } : (val) => val;\n\n        let index = 0;\n        let valueMatchedFromSecondTable: any[];\n        const whereQry = Object.assign({}, joinQuery['whereJoin']);\n        const whereCheker = new WhereChecker(whereQry, (getLength(whereQry) > 0));\n        let joinerComparer: (valueFromSecondTable, valueFromFirstTable) => boolean;\n\n        const performInnerJoin = () => {\n            joinerComparer = (valueFromSecondTable, valueFromFirstTable,) => {\n                return valueFromFirstTable[table1Index][column1] === valueFromSecondTable[column2];\n            }\n            defaultValueSetter = () => { };\n        };\n\n        let defaultValueSetter;\n        const performleftJoin = () => {\n            const columnDefaultValue = {};\n            const nullValue = null;\n            if (joinQuery.store) {\n                getKeys(joinQuery.store).forEach(columnName => {\n                    columnDefaultValue[columnName] = nullValue;\n                })\n            }\n            else {\n                this.getTable(jointblInfo.table2.table).columns.forEach(col => {\n                    columnDefaultValue[col.name] = nullValue;\n                });\n            }\n\n            if (table2Index === 1) {\n                joinerComparer = function (valueFromSecondTable, valueFromFirstTable) {\n                    return valueFromFirstTable[table1Index][column1] === valueFromSecondTable[column2];\n                };\n            }\n            else {\n                joinerComparer = function (valueFromSecondTable, valueFromFirstTable) {\n                    const value = valueFromFirstTable[table1Index];\n                    return value != null && value[column1] === valueFromSecondTable[column2];\n                };\n            }\n\n            defaultValueSetter = () => {\n                if (valueMatchedFromSecondTable.length === 0) {\n                    valueMatchedFromSecondTable = [columnDefaultValue];\n                }\n            }\n        };\n        switch (joinType) {\n            case \"left\":\n                performleftJoin(); break;\n            default:\n                performInnerJoin();\n        }\n        this.results.forEach((valueFromFirstTable) => {\n            valueMatchedFromSecondTable = [];\n            // perform left join\n            secondtableData.forEach(valueFromSecondTable => {\n                if (joinerComparer(valueFromSecondTable, valueFromFirstTable)) {\n                    valueMatchedFromSecondTable.push({\n                        ...valueFromSecondTable\n                    });\n                }\n            });\n\n            defaultValueSetter();\n\n            valueMatchedFromSecondTable.forEach(function (value) {\n                value = mapWithAlias(value);\n                if (!whereCheker.check(value)) return;\n\n                output[index] = { ...valueFromFirstTable };\n                output[index++][table2Index] = value;\n            });\n        });\n        this.results = output;\n    }\n\n    private getJoinTableInfo_(joinOn: string) {\n        joinOn = removeSpace(joinOn);\n        const splittedjoinOn = joinOn.split(\"=\");\n        const splittedjoinOnbydotFirst = splittedjoinOn[0].split(\".\");\n        const splittedjoinOnbydotSecond = splittedjoinOn[1].split(\".\");\n        const info = {\n            table1: {\n                table: splittedjoinOnbydotFirst[0],\n                column: splittedjoinOnbydotFirst[1]\n            },\n            table2: {\n                table: splittedjoinOnbydotSecond[0],\n                column: splittedjoinOnbydotSecond[1]\n            }\n        } as JoinTableInfo;\n        return info;\n    }\n\n    private checkJoinQuery_(jointblInfo: JoinTableInfo, qry: IJoinQuery) {\n        if (qry.store) return null;\n\n        const table1 = jointblInfo.table1;\n        const table2 = jointblInfo.table2;\n        const tableSchemaOf1stTable = this.getTable(table1.table);\n        const tableSchemaOf2ndTable = this.getTable(table2.table);\n        let err: LogHelper;\n        // check on info & with info \n        if (qry.with !== table2.table) {\n            err = new LogHelper(ERROR_TYPE.InvalidJoinQuery,\n                `on value should contains value of with`\n            );\n        }\n\n        // check for column existance\n        if (tableSchemaOf1stTable.columns.find(q => q.name === table1.column) == null) {\n            err = new LogHelper(ERROR_TYPE.InvalidJoinQuery,\n                `column ${table1.column} does not exist in table ${table1.table}`\n            );\n        }\n        else if (tableSchemaOf2ndTable.columns.find(q => q.name === table2.column) == null) {\n            err = new LogHelper(ERROR_TYPE.InvalidJoinQuery,\n                `column ${table2.column} does not exist in table ${table2.table}`\n            );\n        }\n\n        // check for column match in both table\n        if (qry.as == null) {\n            qry.as = {};\n        }\n        tableSchemaOf1stTable.columns.every(function (column) {\n            const columnFound = tableSchemaOf2ndTable.columns.find(q => q.name === column.name && q.name !== table1.column);\n            if (columnFound != null && qry.as[columnFound.name] == null) {\n                err = new LogHelper(ERROR_TYPE.InvalidJoinQuery,\n                    `column ${column.name} exist in both table ${table1.table} & ${table2.table}`\n                );\n                return false;\n            }\n            return true;\n        });\n        let whereQry = qry.where;\n        if (whereQry) {\n            const removeNonExistingColumnFromCurrentTable = (qry, whereJoinParam) => {\n                for (const columnName in qry) {\n                    switch (columnName) {\n                        case \"or\":\n                        case \"in\":\n                            break;\n                        default:\n                            const columnFound = tableSchemaOf2ndTable.columns.find(q => q.name === columnName);\n                            if (!columnFound) {\n                                whereJoinParam[columnName] = qry[columnName];\n                                delete qry[columnName];\n                            }\n                    }\n                }\n            }\n            let whereJoin;\n            if (Array.isArray(whereQry)) {\n                whereJoin = [];\n                whereQry = whereQry.filter(item => {\n                    const whereForExtraColumn = {};\n                    removeNonExistingColumnFromCurrentTable(item, whereForExtraColumn);\n                    if (getLength(whereForExtraColumn) !== 0) {\n                        whereJoin.push(whereForExtraColumn);\n                    }\n                    return getLength(item) !== 0\n                });\n            }\n            else {\n                whereJoin = {};\n                removeNonExistingColumnFromCurrentTable(whereQry, whereJoin);\n            }\n            if (getLength(whereQry) === 0) {\n                qry.where = null;\n            }\n            qry['whereJoin'] = whereJoin;\n        }\n        else {\n            qry['whereJoin'] = {};\n        }\n        return err;\n    }\n}\n\ntype JoinTableInfo = {\n    table1: { table: string, column: string }\n    table2: { table: string, column: string }\n};","import { promiseResolve } from \"@/common\";\nimport { getKeys } from \"../utils\";\n\nexport class MemoryObjectStore {\n    data: any[];\n\n    constructor(data: any[]) {\n        this.data = data;\n    }\n\n    get indexNames() {\n        const keys = getKeys(this.data[0])\n        return {\n            contains(columnName: string) {\n                return keys.indexOf(columnName) >= 0;\n            }\n        }\n    }\n\n    index(column: string) {\n        return {\n            openCursor: (keyRange?: IDBKeyRange) => {\n                const cursorRequest = {\n\n                } as {\n                    onsuccess: Function,\n                    onerror: Function\n                }\n                let index = 0;\n                const cursor = {\n                    continue() {\n                        ++index;\n                        execute();\n                    },\n                }\n                const callOnSuccess = (result) => {\n                    cursorRequest.onsuccess({\n                        target: {\n                            result\n                        }\n                    });\n                }\n                const execute = () => {\n                    const value = this.data[index];\n                    if (value) {\n                        const columnValue = value[column];\n                        if (columnValue && (keyRange == null || keyRange.includes(columnValue))) {\n                            (cursor as any).key = columnValue;\n                            (cursor as any).value = value;\n                            callOnSuccess(cursor)\n                        }\n                        else {\n                            cursor.continue();\n                        }\n                    }\n                    else {\n                        callOnSuccess(null);\n                    }\n                }\n                promiseResolve().then(execute);\n                return cursorRequest;\n            }\n        }\n    }\n}","import { ISelectQuery, QUERY_OPTION, IDB_MODE, API, IWhereQuery, promiseResolve, IOrderQuery } from \"@/common\";\nimport { IDBUtil } from \"@/worker/idbutil\";\nimport { QueryHelper } from \"@worker/executors/query_helper\";\nimport { isArray, isObject, getObjectFirstKey, promiseReject, getLength } from \"@/worker/utils\";\nimport { setPushResult, setLimitAndSkipEvaluationAtEnd, removeDuplicates } from \"./base_select\";\nimport { ThenEvaluator } from \"./then_evaluator\";\nimport { executeWhereUndefinedLogic } from \"./not_where\"\nimport { processAggregateQry, processGroupDistinctAggr, processOrderBy } from \"./order_by\";\nimport { executeAggregateGroupBy, processGroupBy } from \"./group_by\";\nimport { executeWhereLogic } from \"./where\";\nimport { BaseFetch } from \"@executors/base_fetch\";\nimport { executeInLogic } from \"./in\";\nimport { executeRegexLogic } from \"./regex\";\nimport { executeJoinQuery } from \"./join\";\nimport { MemoryObjectStore } from \"@/worker/memory_store\";\n\nexport class Select extends BaseFetch {\n    sorted = false;\n    isOr: boolean;\n    isArrayQry: boolean;\n    query: ISelectQuery;\n    orInfo: {\n        results?: any[];\n        orQuery: object\n    };\n\n    isSubQuery = false;\n\n    protected pushResult: (value) => void;\n\n    protected thenEvaluator = new ThenEvaluator();\n\n    executeWhereUndefinedLogic: typeof executeWhereUndefinedLogic;\n\n    setLimitAndSkipEvaluationAtEnd_: typeof setLimitAndSkipEvaluationAtEnd\n    setPushResult: typeof setPushResult;\n    removeDuplicates: typeof removeDuplicates;\n    executeJoinQuery: typeof executeJoinQuery\n    processGroupDistinctAggr: typeof processGroupDistinctAggr;\n    processOrderBy: typeof processOrderBy;\n    processAggregateQry: typeof processAggregateQry;\n    executeAggregateGroupBy: typeof executeAggregateGroupBy;\n    processGroupBy: typeof processGroupBy;\n\n\n    constructor(query: ISelectQuery, util: IDBUtil) {\n        super();\n        this.query = query;\n        this.util = util;\n        this.tableName = query.from;\n        this.setPushResult();\n        if (isArray(query.where)) {\n            this.isArrayQry = true;\n            this.setLimitAndSkipEvaluationAtEnd_();\n        }\n        else {\n            this.skipRecord = query.skip;\n            this.limitRecord = query.limit;\n        }\n        const orderQuery = query.order;\n        if (orderQuery) {\n            if (isArray(orderQuery) || (orderQuery as IOrderQuery).case || isObject((orderQuery as IOrderQuery).by)) {\n                ((orderQuery as IOrderQuery).idbSorting) = false;\n            }\n            this.setLimitAndSkipEvaluationAtEnd_();\n        }\n        else if (query.groupBy) {\n            this.setLimitAndSkipEvaluationAtEnd_();\n        }\n    }\n\n    execute(beforeExecute?: () => Promise<any>): Promise<any> {\n        let pResult: Promise<void>;\n        if (!beforeExecute) {\n            beforeExecute = () => promiseResolve(null);\n        }\n        const query = this.query;\n        try {\n            const err = new QueryHelper(this.db).validate(API.Select, query);\n            if (err) return promiseReject(err);\n            return beforeExecute().then(_ => {\n                this.initTransaction_();\n                if (query.join == null) {\n                    if (query.where != null) {\n                        if (isArray(query.where)) {\n                            pResult = this.processWhereArrayQry();\n                        }\n                        else {\n                            pResult = this.processWhere_();\n                        }\n                    }\n                    else {\n                        pResult = this.executeWhereUndefinedLogic();\n                    }\n                }\n                else {\n                    pResult = this.executeJoinQuery();\n                }\n                return pResult.then(\n                    this.returnResult_.bind(this)\n                )\n            })\n        }\n        catch (ex) {\n            return this.onException(ex);\n        }\n    }\n\n    private processWhereArrayQry() {\n        this.isArrayQry = true;\n        const whereQuery = this.query.where as IWhereQuery[];\n        const pKey = this.primaryKey();\n        let isFirstWhere = true, output = [], operation;\n\n        const isItemExist = (keyValue) => {\n            return output.findIndex(item => item[pKey] === keyValue) >= 0;\n        };\n        const onSuccess = () => {\n            if (operation === QUERY_OPTION.And) {\n                const doAnd = () => {\n                    let andResults = [];\n                    this.results.forEach((item) => {\n                        if (isItemExist(item[pKey])) {\n                            andResults.push(item);\n                        }\n                    });\n                    output = andResults;\n                    andResults = null;\n                };\n\n                if (isFirstWhere === true) {\n                    output = this.results;\n                }\n                else if (output.length > 0) {\n                    doAnd();\n                }\n            }\n            else {\n                if (output.length > 0) {\n                    this.results = [...output, ...this.results];\n                    this.removeDuplicates();\n                }\n                output = this.results;\n            }\n            isFirstWhere = false;\n            if (whereQuery.length > 0) {\n                this.results = [];\n                return processFirstQry();\n            }\n            else {\n                this.results = output;\n            }\n            return promiseResolve();\n        };\n        const executeWhere = (whereQuery): Promise<any> => {\n            const select = new Select({\n                from: this.query.from,\n                where: whereQuery as any\n            }, this.util);\n            return select.execute().then(results => {\n                this.results = results;\n                return onSuccess();\n            });\n        };\n        const processFirstQry = (): Promise<any> => {\n            let whereQueryToProcess = whereQuery.shift();\n            const whereQueryOr = whereQueryToProcess[QUERY_OPTION.Or];\n            if (whereQueryOr) {\n                if (isArray(whereQueryOr)) {\n                    operation = QUERY_OPTION.Or;\n                    return executeWhere(whereQueryOr);\n                }\n                if (getLength(whereQueryToProcess) === 1) {\n                    operation = QUERY_OPTION.Or;\n                    whereQueryToProcess = whereQueryOr as any;\n                }\n                else {\n                    operation = QUERY_OPTION.And;\n                }\n            }\n            else {\n                operation = QUERY_OPTION.And;\n                if (isArray(whereQueryToProcess)) {\n                    return executeWhere(whereQueryToProcess);\n                }\n            }\n            this.query.where = whereQueryToProcess;\n            return this.processWhere_().then(onSuccess);\n        };\n        return processFirstQry();\n    }\n\n    private initTransaction_() {\n        const store = this.query.store\n        if (store) {\n            this.objectStore = new MemoryObjectStore(store as any[]) as any;\n            return\n        }\n        if (!this.isTxQuery) {\n            this.util.createTransactionIfNotExist([this.tableName], IDB_MODE.ReadOnly);\n        }\n        this.objectStore = this.util.objectStore(this.tableName);\n    }\n\n    private processWhere_() {\n        this.shouldAddValue = (cursor: IDBCursorWithValue) => {\n            const cursorValue = cursor.value;\n            const that = this;\n            const proxy = new Proxy(cursorValue, {\n                get(target, p, receiver) {\n                    let val = cursorValue[p];\n                    if (!val) {\n                        const column = that.getColumnInfo(p as string);\n                        if (column && column.keyPath) {\n                            return column.keyPath.map(col => {\n                                return cursorValue[col];\n                            });\n                        }\n                    }\n                    return val;\n                },\n            });\n            return this.whereChecker.check(proxy);\n        };\n        if ((this.query.where as IWhereQuery).or) {\n            this.processOrLogic_();\n        }\n        return this.goToWhereLogic().then(() => {\n            return this.onWhereEvaluated();\n        })\n    }\n\n    private onWhereEvaluated() {\n        if (this.isOr) {\n            return this.orQuerySuccess_();\n        }\n    }\n\n    private returnResult_ = () => {\n        if (this.results.length > 0) {\n            const query = this.query;\n            if (query.flatten) {\n                const flattendData = [];\n                const indexToDelete = new Map<number, Boolean>();\n                query.flatten.forEach(column => {\n                    this.results.forEach((data, i) => {\n                        data[column].forEach(item => {\n                            flattendData.push(\n                                { ...data, ...{ [column]: item } }\n                            );\n                        });\n                        indexToDelete.set(i, true);\n                    });\n                });\n                let itemsDeleted = 0;\n                indexToDelete.forEach((_, key) => {\n                    this.results.splice(key - itemsDeleted, 1);\n                    ++itemsDeleted;\n                });\n                this.results = this.results.concat(flattendData);\n            }\n            this.processGroupDistinctAggr();\n            this.processOrderBy();\n            if (this.skipAtEnd) {\n                this.results.splice(0, query.skip);\n            }\n            if (this.limitAtEnd) {\n                this.results = this.results.slice(0, query.limit);\n            }\n        }\n        return this.results;\n    }\n\n    private orQueryFinish_() {\n        this.isOr = false;\n        this.results = this.orInfo.results;\n        // free or info memory\n        this.orInfo = null;\n        this.removeDuplicates();\n        // this.onQueryFinished();\n    }\n\n    private orQuerySuccess_() {\n        const query = this.query;\n        if (this.results.length > 0) {\n            this.orInfo.results = [... this.orInfo.results, ...this.results];\n        }\n\n        this.results = [];\n        const key = getObjectFirstKey(this.orInfo.orQuery);\n        if (key != null) {\n            const where = {};\n            where[key] = this.orInfo.orQuery[key];\n            delete this.orInfo.orQuery[key];\n            query.where = where;\n            return this.goToWhereLogic().then(this.onWhereEvaluated.bind(this))\n        }\n        return this.orQueryFinish_();\n    }\n\n    private processOrLogic_() {\n        this.isOr = true;\n        const where = this.query.where as IWhereQuery;\n        this.orInfo = {\n            orQuery: where.or as any,\n            results: []\n        };\n        this.setLimitAndSkipEvaluationAtEnd_();\n        // free or memory\n        delete where.or;\n    }\n}\n\nSelect.prototype.executeInLogic = executeInLogic;\nSelect.prototype.executeWhereUndefinedLogic = executeWhereUndefinedLogic;\nSelect.prototype.executeWhereLogic = executeWhereLogic;\nSelect.prototype.executeRegexLogic = executeRegexLogic;\n\nSelect.prototype.setLimitAndSkipEvaluationAtEnd_ = setLimitAndSkipEvaluationAtEnd\nSelect.prototype.setPushResult = setPushResult;\nSelect.prototype.removeDuplicates = removeDuplicates;\nSelect.prototype.executeJoinQuery = executeJoinQuery\nSelect.prototype.processGroupDistinctAggr = processGroupDistinctAggr;\nSelect.prototype.processOrderBy = processOrderBy;\nSelect.prototype.processAggregateQry = processAggregateQry;\nSelect.prototype.executeAggregateGroupBy = executeAggregateGroupBy;\nSelect.prototype.processGroupBy = processGroupBy;\n","export const isObject = (value) => {\n    return typeof value === 'object';\n};","import { Select } from \"./\";\nimport { promise, promiseAll } from \"@/common\";\nimport { BaseFetch } from \"../base_fetch\";\nimport { executeLimitForWhere_, executeSimpleForWhere_, getCursorOnSuccess } from \"./where\";\nimport { executeSkipAndLimitForWhere_, executeSkipForWhere_ } from \"./regex\";\n\nexport const executeInLogic = function (this: BaseFetch, column, values) {\n    let skip = this.skipRecord;\n    const skipOrPush = (val) => {\n        if (skip === 0) {\n            (this as Select)['pushResult'](val);\n        }\n        else {\n            --skip;\n        }\n    };\n    const onSuccess = getCursorOnSuccess.call(\n        this,\n        executeSimpleForWhere_,\n        executeLimitForWhere_,\n        executeSkipForWhere_,\n        executeSkipAndLimitForWhere_\n    );\n\n    const runInLogic: (val) => Promise<void> = (value) => {\n        return promise((res, rej) => {\n            const cursorRequest = this.objectStore.index(column).openCursor(\n                this.util.keyRange(value)\n            );\n            cursorRequest.onsuccess = onSuccess.call(this, res, skipOrPush);\n            cursorRequest.onerror = rej;\n        });\n    };\n\n    return promiseAll<void>(\n        values.map(runInLogic)\n    );\n\n};\n","import { Select } from \"./index\";\n\nexport const setPushResult = function (this: Select) {\n    const caseQuery = this.query.case;\n    if (caseQuery) {\n        this.pushResult = (value) => {\n            let columnName: string;\n            this.thenEvaluator.setCaseAndValue(caseQuery, value);\n            for (columnName in caseQuery) {\n                value[columnName] = this.thenEvaluator.setColumn(columnName).evaluate();\n            }\n            this.results.push(value);\n        };\n    }\n    else {\n        this.pushResult = (value) => {\n            this.results.push(value);\n        };\n    }\n}\n\nexport const setLimitAndSkipEvaluationAtEnd = function (this: Select) {\n    if (this.query.limit) {\n        this.limitAtEnd = true;\n    }\n    if (this.query.skip) {\n        this.skipAtEnd = true;\n    }\n}\n\nexport const removeDuplicates = function (this: Select) {\n    let datas = this.results;\n    const key = this.primaryKey();\n    const lookupObject = new Map();\n    for (let i = 0, len = datas.length; i < len; i++) {\n        lookupObject.set(datas[i][key], datas[i]);\n    }\n\n    this.results = Array.from(lookupObject.values());\n}","import { Select } from \".\";\nimport { getDataType, getObjectFirstKey } from \"@/worker/utils\";\nimport { QUERY_OPTION, DATA_TYPE } from \"@/common\";\n\nexport const processGroupBy = function (this: Select) {\n    const groupBy = this.query.groupBy as any;\n    let datas = this.results;\n    const lookUpObj = new Map<string, any>();\n\n    const groupByDataType = getDataType(groupBy);\n    if (groupByDataType !== DATA_TYPE.Object) {\n        if (groupByDataType === DATA_TYPE.String) {\n            for (const i in datas) {\n                lookUpObj.set(datas[i][groupBy as string], datas[i]);\n            }\n        }\n        else {\n            let objKey;\n            for (const i in datas) {\n                objKey = \"\";\n                for (const column in groupBy) {\n                    objKey += datas[i][groupBy[column]];\n                }\n                lookUpObj.set(objKey, datas[i]);\n            }\n        }\n    }\n    else {\n        const caseQueryLength = Object.keys(groupBy).length;\n        if (caseQueryLength === 1) {\n            const groupByColumn = getObjectFirstKey(groupBy);\n            this.thenEvaluator.setCaseAndColumn(groupBy, groupByColumn);\n            for (const i in datas) {\n                lookUpObj.set(this.thenEvaluator.setValue(datas[i]).evaluate(), datas[i]);\n            }\n        }\n        else {\n            let objKey;\n            for (const i in datas) {\n                objKey = \"\";\n                this.thenEvaluator.setCaseAndValue(groupBy, datas[i]);\n                for (const column in groupBy) {\n                    objKey += this.thenEvaluator.setColumn(column).evaluate();\n                }\n                lookUpObj.set(objKey, datas[i]);\n            }\n        }\n    }\n\n    this.results = Array.from(lookUpObj.values());\n}\n\nexport const executeAggregateGroupBy = function (this: Select) {\n    const grpQry = this.query.groupBy as any;\n    let datas = this.results;\n\n    const lookUpObj = new Map<string, any>();\n    // assign aggregate\n    const aggregateQry = this.query.aggregate;\n\n    let index;\n    let objKey;\n    let value;\n    let columnToAggregate;\n    const calculateAggregate = () => {\n        const getCount = () => {\n            value = lookUpObj.get(objKey);\n            // get old value\n            value = value ? value[\"count(\" + columnToAggregate + \")\"] : 0;\n            // add with old value if data exist\n            value += datas[index][columnToAggregate] ? 1 : 0;\n            return value;\n        };\n        const getList = () => {\n            value = lookUpObj.get(objKey);\n            // get old value\n            value = value ? value[\"list(\" + columnToAggregate + \")\"] : [];\n            // push value\n            value.push(datas[index][columnToAggregate]);\n            return value;\n        };\n        const getMax = () => {\n            value = lookUpObj.get(objKey);\n            // get old value\n            value = value ? value[\"max(\" + columnToAggregate + \")\"] : 0;\n            datas[index][columnToAggregate] = datas[index][columnToAggregate] ?\n                datas[index][columnToAggregate] : 0;\n            // compare between old value and new value\n            return value > datas[index][columnToAggregate] ? value : datas[index][columnToAggregate];\n        };\n        const getMin = () => {\n            value = lookUpObj.get(objKey);\n            // get old value\n            value = value ? value[\"min(\" + columnToAggregate + \")\"] : Infinity;\n            datas[index][columnToAggregate] = datas[index][columnToAggregate] ?\n                datas[index][columnToAggregate] : Infinity;\n            // compare between old value and new value\n            return value < datas[index][columnToAggregate] ? value : datas[index][columnToAggregate];\n        };\n        const getSum = () => {\n            value = lookUpObj.get(objKey);\n            // get old value\n            value = value ? value[\"sum(\" + columnToAggregate + \")\"] : 0;\n            // add with old value if data exist\n            value += datas[index][columnToAggregate] ? datas[index][columnToAggregate] : 0;\n            return value;\n        };\n        const getAvg = () => {\n            value = lookUpObj.get(objKey)\n            // get old sum value\n            let sumOfColumn = value ? value[\"sum(\" + columnToAggregate + \")\"] : 0;\n            // add with old value if data exist\n            sumOfColumn += datas[index][columnToAggregate] ? datas[index][columnToAggregate] : 0;\n            datas[index][\"sum(\" + columnToAggregate + \")\"] = sumOfColumn;\n            // get old count value\n            value = value ? value[\"count(\" + columnToAggregate + \")\"] : 0;\n            // add with old value if data exist\n            value += datas[index][columnToAggregate] ? 1 : 0;\n            datas[index][\"count(\" + columnToAggregate + \")\"] = value;\n        };\n        for (const prop in aggregateQry) {\n            const aggregateColumn = aggregateQry[prop];\n            const aggregateValType = getDataType(aggregateColumn);\n            let aggregateCalculator;\n            switch (prop) {\n                case QUERY_OPTION.Count:\n                    aggregateCalculator = getCount;\n                    break;\n                case QUERY_OPTION.Max:\n                    aggregateCalculator = getMax;\n                    break;\n                case QUERY_OPTION.Min:\n                    aggregateCalculator = getMin;\n                    break;\n                case QUERY_OPTION.Sum:\n                    aggregateCalculator = getSum;\n                    break;\n                case QUERY_OPTION.Avg:\n                    aggregateCalculator = getAvg;\n                    break;\n                case QUERY_OPTION.List:\n                    aggregateCalculator = getList;\n                    break;\n            }\n            switch (aggregateValType) {\n                case DATA_TYPE.String:\n                    columnToAggregate = aggregateColumn;\n                    datas[index][`${prop}(${columnToAggregate})`] = aggregateCalculator();\n                    break;\n                case DATA_TYPE.Array:\n                    for (const item in aggregateColumn) {\n                        columnToAggregate = aggregateColumn[item];\n                        datas[index][`${prop}(${columnToAggregate})`] = aggregateCalculator();\n                    }\n            }\n        }\n    };\n\n    if (getDataType(grpQry) === DATA_TYPE.String) {\n        for (index in datas) {\n            objKey = datas[index][grpQry];\n            calculateAggregate();\n            lookUpObj.set(objKey, datas[index]);\n        }\n    }\n    else {\n        for (index in datas) {\n            objKey = \"\";\n            for (const column in grpQry) {\n                objKey += datas[index][grpQry[column]];\n            }\n            calculateAggregate();\n            lookUpObj.set(objKey, datas[index]);\n        }\n\n    }\n    datas = Array.from(lookUpObj.values());\n\n    // Checking for avg and if exist then fill the datas;\n    const avgQuery = aggregateQry.avg;\n    if (avgQuery) {\n        if (getDataType(avgQuery) === DATA_TYPE.String) {\n            for (index in datas) {\n                const sumForAvg = datas[index][\"sum(\" + avgQuery + \")\"],\n                    countForAvg = datas[index][\"count(\" + avgQuery + \")\"];\n                datas[index][\"avg(\" + avgQuery + \")\"] = sumForAvg / countForAvg;\n                if (aggregateQry.count !== avgQuery) {\n                    delete datas[index][\"count(\" + avgQuery + \")\"];\n                }\n                if (aggregateQry.sum !== avgQuery) {\n                    delete datas[index][\"sum(\" + avgQuery + \")\"];\n                }\n            }\n        }\n        else {\n            const isCountTypeString = getDataType(aggregateQry.count) === DATA_TYPE.String;\n            const isSumTypeString = getDataType(aggregateQry.sum) === DATA_TYPE.String;\n            for (index in datas) {\n                for (const column in avgQuery as any) {\n                    const avgColumn = avgQuery[column],\n                        sum = datas[index][\"sum(\" + avgColumn + \")\"],\n                        count = datas[index][\"count(\" + avgColumn + \")\"];\n                    datas[index][\"avg(\" + avgColumn + \")\"] = sum / count;\n\n                    if (isCountTypeString) {\n                        if (aggregateQry.count !== avgColumn) {\n                            delete datas[index][\"count(\" + avgColumn + \")\"];\n                        }\n                        else if (aggregateQry.count.indexOf(avgColumn) === -1) {\n                            delete datas[index][\"count(\" + avgColumn + \")\"];\n                        }\n                    }\n\n                    if (isSumTypeString) {\n                        if (aggregateQry.sum !== avgColumn) {\n                            delete datas[index][\"sum(\" + avgColumn + \")\"];\n                        }\n                        else if (aggregateQry.sum.indexOf(avgColumn) === -1) {\n                            delete datas[index][\"sum(\" + avgColumn + \")\"];\n                        }\n                    }\n                }\n            }\n        }\n    }\n    this.results = datas;\n}\n","import { promise } from \"@/common\";\nimport { BaseFetch } from \"../base_fetch\";\nimport { Count } from \".\";\n\nexport const executeWhereUndefinedLogic = function (this: BaseFetch) {\n    let countRequest;\n    const objectStore = this.objectStore;\n    const onSuccess = (() => {\n        if (objectStore.count) {\n            countRequest = objectStore.count();\n            return (onFinish) => {\n                return () => {\n                    (this as Count).resultCount = countRequest.result;\n                    onFinish();\n                }\n            }\n        }\n        else {\n            let cursor;\n            countRequest = objectStore.openCursor();\n            return (onFinish) => {\n                return (e: any) => {\n                    cursor = e.target.result;\n                    if (cursor) {\n                        ++(this as Count).resultCount;\n                        cursor.continue();\n                    }\n                    else {\n                        onFinish();\n                    }\n                };\n            };\n        }\n    })();\n    return promise((res, rej) => {\n        countRequest.onerror = rej;\n        countRequest.onsuccess = onSuccess(res);\n    });\n}\n","import { BaseFetch } from \"../base_fetch\";\nimport { getLength } from \"@/worker/utils\";\nimport { Count } from \".\";\nimport { promise } from \"@/common\";\n\nexport const onWhereCount = function (this: BaseFetch, onFinish) {\n    return (e) => {\n        const cursor = e.target.result;\n        if (cursor) {\n            if (this.shouldAddValue(cursor)) {\n                ++(this as Count).resultCount;\n            }\n            cursor.continue();\n        }\n        else {\n            onFinish();\n        }\n    }\n}\n\nexport const executeWhereLogic = function (this: BaseFetch, column, value, op) {\n    value = op ? value[op] : value;\n    let cursorRequest;\n\n    const isWhereKeysLengthOne = getLength(this.query.where) === 1;\n    const objectStore = this.objectStore;\n\n    return promise((res, rej) => {\n        if (isWhereKeysLengthOne && objectStore.count) {\n            cursorRequest = objectStore.index(column).count(this.util.keyRange(value, op));\n            cursorRequest.onsuccess = () => {\n                (this as Count).resultCount = cursorRequest.result;\n                res();\n            }\n        }\n        else {\n            cursorRequest = objectStore.index(column).openCursor(this.util.keyRange(value, op));\n            cursorRequest.onsuccess = onWhereCount.call(this, res);\n        }\n        cursorRequest.onerror = rej;\n    });\n}","import { BaseFetch } from \"@executors/base_fetch\";\nimport { Select } from \"@executors/select\";\nimport { ICountQuery, ISelectQuery, IDB_MODE, API, IWhereQuery } from \"@/common\";\nimport { IDBUtil } from \"@/worker/idbutil\";\nimport { QueryHelper } from \"@executors/query_helper\";\nimport { promiseReject, isArray } from \"@worker/utils\";\nimport { executeWhereUndefinedLogic } from \"@executors/count/not_where\";\nimport { executeWhereLogic } from \"./where\";\nimport { executeRegexLogic } from \"./regex\";\nimport { executeInLogic } from \"./in\";\n\nexport class Count extends BaseFetch {\n\n    query: ICountQuery;\n    resultCount: number = 0;\n    executeWhereUndefinedLogic: typeof executeWhereUndefinedLogic;\n\n    constructor(query: ICountQuery, util: IDBUtil) {\n        super();\n        this.query = query;\n        this.util = util;\n        this.tableName = query.from;\n    }\n\n    execute(beforeExecute: () => Promise<any>) {\n        const queryHelper = new QueryHelper(this.db);\n        const query = this.query;\n        const err = queryHelper.validate(API.Count, query);\n        if (err) {\n            return promiseReject(\n                err\n            );\n        }\n        return beforeExecute().then(_ => {\n            let result: Promise<void>;\n            try {\n                const getDataFromSelect = () => {\n                    const selectInstance = new Select(query as ISelectQuery, this.util);\n                    selectInstance.isTxQuery = this.isTxQuery;\n                    return selectInstance.execute().then(results => {\n                        this.resultCount = results.length;\n                    });\n                };\n                this.initTransaction_();\n                if (query.join == null) {\n                    if (query.where != null) {\n                        if ((query.where as IWhereQuery).or || isArray(query.where)) {\n                            result = getDataFromSelect();\n                        }\n                        else {\n                            this.shouldAddValue = (cursor) => {\n                                return this.whereChecker.check(cursor.value);\n                            };\n                            result = this.goToWhereLogic();\n                        }\n                    }\n                    else {\n                        result = this.executeWhereUndefinedLogic() as any;\n                    }\n                }\n                else {\n                    result = getDataFromSelect();\n                }\n            }\n            catch (ex) {\n                this.onException(ex);\n            }\n            return result.then(_ => {\n                return this.resultCount;\n            })\n        });\n    }\n\n    private initTransaction_() {\n        const tableName = this.query.from;\n        if (!this.isTxQuery) {\n            this.util.createTransaction([tableName], IDB_MODE.ReadOnly);\n        }\n        this.objectStore = this.util.objectStore(tableName);\n    }\n}\n\nCount.prototype.executeWhereUndefinedLogic = executeWhereUndefinedLogic;\nCount.prototype.executeWhereLogic = executeWhereLogic\nCount.prototype.executeRegexLogic = executeRegexLogic\nCount.prototype.executeInLogic = executeInLogic","import { BaseFetch } from \"../base_fetch\";\nimport { promise } from \"@/common\";\nimport { onWhereCount } from \"./where\";\n\nexport const executeRegexLogic = function (this: BaseFetch, column: string, exp: RegExp) {\n    const cursorRequest = this.objectStore.index(column).openCursor();\n    this.shouldAddValue = (cursor) => {\n        return exp.test(cursor.key) &&\n            this.whereChecker.check(cursor.value);\n    };\n    return promise((res, rej) => {\n        cursorRequest.onerror = rej;\n        cursorRequest.onsuccess = onWhereCount.call(this, res);\n    })\n}","import { promise, promiseAll } from \"@/common\";\nimport { getLength } from \"@/worker/utils\";\nimport { BaseFetch } from \"../base_fetch\";\nimport { onWhereCount } from \"./where\";\n\n\nexport const executeInLogic = function (this: BaseFetch, column, values) {\n    const objectStore = this.objectStore;\n    const columnStore = objectStore.index(column);\n    const isWhereKeysLengthOne = getLength(this.query.where) === 1;\n\n    const runInLogic: (val) => Promise<void> = (value) => {\n        const keyRange = this.util.keyRange(value);\n        if (isWhereKeysLengthOne && objectStore.count) {\n            return promise((res, rej) => {\n                const cursorRequest = columnStore.count(keyRange);\n                cursorRequest.onsuccess = (e: any) => {\n                    this.resultCount += e.target.result;\n                    res();\n                };\n                cursorRequest.onerror = rej;\n            });\n        }\n        return promise<void>((res, rej) => {\n            const cursorRequest = columnStore.openCursor(keyRange);\n            cursorRequest.onsuccess = onWhereCount.call(this, res);\n            cursorRequest.onerror = rej;\n        });\n    };\n\n    return promiseAll<void>(\n        values.map(function (val) {\n            return runInLogic(val);\n        })\n    );\n}\n","import { isArray } from \"./is_array\";\n\nexport const variableFromPath = (path: string) => {\n    const properties: string[] = isArray(path) ? path as any : path.split(\".\");\n    return properties.reduce((prev, curr) => prev && prev[curr], self);\n}","import { getDataType, variableFromPath, promiseReject, LogHelper } from \"@worker/utils\";\nimport { DATA_TYPE, ERROR_TYPE, IUpdateQuery } from \"@/common\";\n\nexport const updateValue = (query: IUpdateQuery, storedValue) => {\n    let setValue = query.set;\n    const mapSet = query.mapSet;\n    if (mapSet) {\n        const result = (mapSet as Function)(setValue, storedValue);\n        if (result != null) {\n            setValue = result;\n        }\n    }\n    for (const key in setValue) {\n        const columnSetValue = setValue[key];\n        if (getDataType(columnSetValue) !== DATA_TYPE.Object) {\n            storedValue[key] = columnSetValue;\n        }\n        else {\n            for (const op in columnSetValue) {\n                let value = columnSetValue[op];\n                switch (op as any) {\n                    case '+': storedValue[key] += value; break;\n                    case '-': storedValue[key] -= value; break;\n                    case '*': storedValue[key] *= value; break;\n                    case '/': storedValue[key] /= value; break;\n                    case '{push}': storedValue[key].push(value); break;\n                    default: storedValue[key] = columnSetValue;\n                }\n                break;\n            }\n        }\n    }\n    return storedValue;\n};","import { IUpdateQuery, ISelectQuery, QUERY_OPTION, API, IWhereQuery, DATA_TYPE, ERROR_TYPE } from \"@/common\";\nimport { IDBUtil } from \"@/worker/idbutil\";\nimport { DbMeta } from \"@worker/model\";\nimport { QueryHelper } from \"../query_helper\";\nimport { promiseReject, isArray, getDataType, variableFromPath, LogHelper } from \"@worker/utils\";\nimport { BaseFetch } from \"@executors/base_fetch\";\nimport { Select } from \"@executors/select\";\nimport { executeWhereUndefinedLogic } from \"./not_where\";\nimport { executeInLogic } from \"./in\";\nimport { executeRegexLogic } from \"./regex\";\nimport { executeWhereLogic } from \"./where\";\n\nexport class Update extends BaseFetch {\n    executeWhereUndefinedLogic: typeof executeWhereUndefinedLogic\n\n    constructor(query: IUpdateQuery, util: IDBUtil) {\n        super();\n        this.query = query as any;\n        this.util = util;\n        this.tableName = query.in;\n        const mapSet = query.mapSet;\n        if (mapSet) {\n            const method = getDataType(mapSet) === DATA_TYPE.String ?\n                variableFromPath(mapSet as string) : mapSet;\n            if (!method) {\n                throw new LogHelper(ERROR_TYPE.MethodNotExist, mapSet);\n            }\n            query.mapSet = method;\n        }\n\n    }\n\n    execute(beforeExecute: () => Promise<any>) {\n        const query: IUpdateQuery = this.query as any;\n        try {\n            const queryHelper = new QueryHelper(this.db);\n            const err = queryHelper.validate(API.Update, query);\n            if (err) return promiseReject(err);\n            return beforeExecute().then(_ => {\n                this.initTransaction();\n                let pResult: Promise<void>;\n                if (query.where != null) {\n                    if ((query.where as IWhereQuery).or || isArray(query.where)) {\n                        pResult = this.executeComplexLogic_();\n                    }\n                    else {\n                        pResult = this.goToWhereLogic();\n                    }\n                }\n                else {\n                    pResult = this.executeWhereUndefinedLogic();\n                }\n                return pResult.then(() => {\n                    return this.rowAffected;\n                })\n            })\n        }\n        catch (ex) {\n            return this.onException(ex);\n        }\n    }\n\n    private executeComplexLogic_() {\n        const query: IUpdateQuery = this.query as any;\n        const selectObject = new Select({\n            from: query.in,\n            where: query.where,\n            ignoreCase: query.ignoreCase\n        } as ISelectQuery, this.util);\n        selectObject.isTxQuery = this.isTxQuery;\n        return selectObject.execute().then((results: any[]) => {\n            const key = this.primaryKey(query.in);\n            const inQuery = [];\n            results.forEach((value) => {\n                inQuery.push(value[key]);\n            });\n            results = null;\n            const whereQry = { [key]: { [QUERY_OPTION.In]: inQuery } };\n            this.query.where = whereQry;\n            this.initTransaction();\n            return this.goToWhereLogic();\n        });\n    }\n\n    private initTransaction() {\n        const tableName = (this.query as any).in;\n        if (!this.isTxQuery) {\n            this.util.createTransaction([tableName]);\n        }\n        this.objectStore = this.util.objectStore(tableName);\n    }\n}\n\nUpdate.prototype.executeWhereUndefinedLogic = executeWhereUndefinedLogic;\nUpdate.prototype.executeWhereLogic = executeWhereLogic\nUpdate.prototype.executeRegexLogic = executeRegexLogic\nUpdate.prototype.executeInLogic = executeInLogic","import { Update } from \"./\";\nimport { promise } from \"@/common\";\nimport { updateValue } from \"./update_value\";\n\n\nexport const executeWhereUndefinedLogic = function (this: Update) {\n    const cursorRequest: IDBRequest<IDBCursorWithValue> = this.objectStore.openCursor();\n    return promise<void>((res, rej) => {\n        cursorRequest.onsuccess = (e: any) => {\n            const cursor: IDBCursorWithValue = (e as any).target.result;\n            if (cursor) {\n                try {\n                    const cursorUpdateRequest = cursor.update(updateValue(this.query as any, cursor.value));\n                    cursorUpdateRequest.onsuccess = () => {\n                        ++this.rowAffected;\n                        cursor.continue();\n                    };\n                    cursorUpdateRequest.onerror = rej;\n                } catch (ex) {\n                    rej(\n                        ex\n                    );\n                }\n            }\n            else {\n                res();\n            }\n        };\n        cursorRequest.onerror = rej;\n    })\n\n}\n","import { promise, IUpdateQuery } from \"@/common\";\nimport { updateValue } from \"./update_value\";\nimport { Update } from \"./\";\n\nexport const executeWhereLogic = function (this: Update, column, value, op) {\n    const query: IUpdateQuery = this.query as any;\n    value = op ? value[op] : value;\n    const cursorRequest = this.objectStore.index(column).openCursor(this.util.keyRange(value, op));\n    return promise<void>((res, rej) => {\n        cursorRequest.onsuccess = (e: any) => {\n            const cursor: IDBCursorWithValue = e.target.result;\n            if (cursor) {\n                if (this.whereChecker.check(cursor.value)) {\n                    try {\n                        const cursorUpdateRequest = cursor.update(updateValue(query, cursor.value));\n                        cursorUpdateRequest.onsuccess = () => {\n                            ++this.rowAffected;\n                            cursor.continue();\n                        };\n                        cursorUpdateRequest.onerror = rej;\n                    } catch (ex) {\n                        rej(\n                            ex\n                        );\n                    }\n                }\n                else {\n                    cursor.continue();\n                }\n            }\n            else {\n                res();\n            }\n        };\n        cursorRequest.onerror = rej\n    })\n}","import { Update } from \"./\";\nimport { updateValue } from \"./update_value\";\nimport { promise } from \"@/common\";\n\nexport const executeRegexLogic = function (this: Update, column: string, exp: RegExp) {\n    let cursor: IDBCursorWithValue;\n    const cursorOpenRequest = this.objectStore.index(column).openCursor();\n    this.shouldAddValue = (cursor) => {\n        return exp.test(cursor.key) &&\n            this.whereChecker.check(cursor.value);\n    };\n    return promise<void>((res, rej) => {\n\n        cursorOpenRequest.onsuccess = (e: any) => {\n            cursor = e.target.result;\n            if (cursor) {\n                if (this.shouldAddValue(cursor)) {\n                    try {\n                        const cursorUpdateRequest = cursor.update(updateValue(this.query as any, cursor.value));\n                        cursorUpdateRequest.onsuccess = () => {\n                            ++this.rowAffected;\n                            cursor.continue();\n                        };\n                        cursorUpdateRequest.onerror = rej;\n                    } catch (ex) {\n                        rej(\n                            ex\n                        );\n                    }\n                }\n                else {\n                    cursor.continue();\n                }\n\n            }\n            else {\n                res();\n            }\n        };\n        cursorOpenRequest.onerror = rej;\n    })\n\n}\n","import { Update } from \"./\";\nimport { promiseAll, promise, IUpdateQuery } from \"@/common\";\nimport { updateValue } from \"./update_value\";\n\n\nexport const executeInLogic = function (this: Update, column, values: any[]) {\n    const columnStore = this.objectStore.index(column);\n    const query: IUpdateQuery = this.query as any;\n    const runInLogic: (val) => Promise<void> = (value) => {\n        return promise((res, rej) => {\n            const cursorRequest = columnStore.openCursor(this.util.keyRange(value));\n            cursorRequest.onsuccess = (e: any) => {\n                const cursor: IDBCursorWithValue = e.target.result;\n                if (cursor) {\n                    const value = cursor.value;\n                    if (this.whereChecker.check(value)) {\n                        try {\n                            const cursorUpdateRequest = cursor.update(updateValue(query, value));\n                            cursorUpdateRequest.onsuccess = () => {\n                                ++this.rowAffected;\n                                cursor.continue();\n                            };\n                            cursorUpdateRequest.onerror = rej;\n                        }\n                        catch (ex) {\n                            rej(\n                                ex\n                            );\n                        }\n\n                    }\n                    else {\n                        cursor.continue();\n                    }\n                }\n                else {\n                    res();\n                }\n            };\n            cursorRequest.onerror = rej;\n        });\n    };\n\n    return promiseAll<void>(\n        values.map(function (val) {\n            return runInLogic(val);\n        })\n    );\n}\n","import { IIntersectQuery, ISelectQuery } from \"@/common\";\nimport { Base } from \"@executors/base\";\nimport { Select } from \"@executors/select\";\n\nexport class Intersect extends Base {\n\n    constructor(intersectQry: IIntersectQuery, util) {\n        super();\n        this.query = intersectQry as any;\n        this.util = util;\n    }\n\n    execute() {\n        const intersectQry: IIntersectQuery = this.query as any;\n        let index = 0;\n        let hashMap = {};\n        let hashMapTemp = {};\n        let isQueryForSameTable = true;\n        const queries = intersectQry.queries;\n        const queryLength = queries.length;\n        queries.every((qry, i) => {\n            if (i + 1 < queryLength && qry.from !== queries[i + 1].from) {\n                isQueryForSameTable = false;\n                return false;\n            }\n            return true;\n        });\n        let getHashKey;\n        if (isQueryForSameTable) {\n            const pKey = this.primaryKey(queries[0].from);\n            getHashKey = (val) => {\n                return val[pKey];\n            };\n        }\n        else {\n            getHashKey = (val) => {\n                let columnValKey = \"\";\n                for (const key in val) {\n                    columnValKey += val[key];\n                }\n                return columnValKey;\n            };\n        }\n\n        let select: Select;\n        const fetchData = () => {\n            if (index < queryLength) {\n                select = new Select(queries[index], this.util);\n                return select.execute().then((selectResult) => {\n                    hashMap = {};\n                    selectResult.forEach(val => {\n                        const columnValKey = getHashKey(val);\n                        if (index === 0) {\n                            hashMapTemp[columnValKey] = val;\n                        } else if (hashMapTemp[columnValKey] != null) {\n                            hashMap[columnValKey] = val;\n                        }\n                    });\n                    if (index > 0) {\n                        hashMapTemp = { ...hashMap };\n                    }\n\n                    ++index;\n                    return fetchData();\n                })\n            }\n            else {\n                const results = [];\n                let resultPusher: (key: string) => void;\n                let skip = intersectQry.skip;\n                const limit = intersectQry.limit;\n                const onFinished = () => {\n                    select['results'] = results;\n                    Object.assign(select.query, {\n                        order: intersectQry.order,\n                        join: {} as any\n                    } as ISelectQuery);\n                    select.processOrderBy();\n                    select.processGroupDistinctAggr();\n                    return (select['results']);\n                };\n                let shouldStopLoop = false;\n                let key: string;\n                const pushResult = () => {\n                    results.push(hashMap[key]);\n                };\n                const checkLimitAndPush = () => {\n                    if (results.length < limit) {\n                        pushResult();\n                    }\n                    else {\n                        shouldStopLoop = true;\n                    }\n                };\n                const skipChecker = (callBack: () => void) => {\n                    if (skip === 0) {\n                        callBack();\n                    }\n                    else {\n                        --skip;\n                    }\n                };\n                if (intersectQry.skip && intersectQry.limit) {\n                    resultPusher = () => {\n                        skipChecker(() => {\n                            checkLimitAndPush();\n                        });\n                    };\n\n                }\n                else if (intersectQry.limit) {\n                    resultPusher = checkLimitAndPush;\n                }\n                else if (intersectQry.skip) {\n                    resultPusher = () => {\n                        skipChecker(() => {\n                            pushResult();\n                        });\n                    };\n                }\n                else {\n                    resultPusher = () => {\n                        pushResult();\n                    };\n                }\n                if (limit) {\n                    for (key in hashMap) {\n                        resultPusher(key);\n                        if (shouldStopLoop) {\n                            break;\n                        }\n                    }\n                }\n                else {\n                    for (key in hashMap) {\n                        resultPusher(key);\n                    }\n                }\n                return onFinished();\n            }\n        };\n        return fetchData();\n    }\n}","import { LogHelper, getError } from \"@worker/utils\";\nimport { ERROR_TYPE, promise } from \"@/common\";\n\nexport class DropDb {\n\n    execute(dbName: string) {\n        return promise((res, rej) => {\n            const dropDbRequest = indexedDB.deleteDatabase(dbName);\n            dropDbRequest.onblocked = () => {\n                const err = new LogHelper(ERROR_TYPE.DbBlocked);\n                return rej(\n                    getError(err)\n                );\n            };\n            dropDbRequest.onerror = (e) => {\n                return rej(\n                    getError(e)\n                )\n            };\n            dropDbRequest.onsuccess = () => {\n                res();\n            };\n        })\n    }\n}\n","import { Base } from \"@executors/base\";\nimport { ISelectQuery } from \"@/common\";\nimport { Select } from \"@executors/select\";\nimport { IDBUtil } from \"@/worker/idbutil\";\n\nexport class Union extends Base {\n\n    constructor(query: ISelectQuery[], util: IDBUtil) {\n        super();\n        this.query = query as any;\n        this.util = util;\n    }\n\n    execute() {\n        const query: ISelectQuery[] = this.query as any;\n        let index = 0;\n        const hashMap = new Map();\n        let isQueryForSameTable = true;\n        const queryLength = query.length;\n        query.every((qry, i) => {\n            if (i + 1 < queryLength && qry.from !== query[i + 1].from) {\n                isQueryForSameTable = false;\n                return false;\n            }\n            return true;\n        });\n        let getHashKey;\n        if (isQueryForSameTable) {\n            const pKey = this.primaryKey(query[0].from);\n            getHashKey = (val) => {\n                return val[pKey];\n            };\n        }\n        else {\n            getHashKey = (val) => {\n                let columnValKey = \"\";\n                for (const key in val) {\n                    columnValKey += val[key];\n                }\n                return columnValKey;\n            };\n        }\n        let select: Select;\n        const fetchData = () => {\n            if (index < query.length) {\n                select = new Select(query[index++], this.util);\n                return select.execute().then((selectResult) => {\n                    selectResult.forEach(val => {\n                        hashMap.set(getHashKey(val), val);\n                    });\n                    return fetchData();\n                })\n            }\n            else {\n                return Array.from(hashMap.values());\n            }\n        };\n        return fetchData();\n    }\n\n\n}","import { Remove } from \".\";\nimport { promise } from \"@/common\";\n\nexport const onWhereRemove = function (this: Remove, onFinish) {\n    return (e) => {\n        const cursor: IDBCursorWithValue = e.target.result;\n        if (cursor) {\n            if (this.shouldAddValue(cursor.value)) {\n                cursor.delete();\n                ++this.rowAffected;\n            }\n            cursor.continue();\n        }\n        else {\n            onFinish();\n        }\n    };\n}\n\nexport const executeWhereLogic = function (this: Remove, column, value, op) {\n    value = op ? value[op] : value;\n    const cursorRequest = this.objectStore.index(column).openCursor(this.util.keyRange(value, op));\n\n\n    return promise<void>((res, rej) => {\n        cursorRequest.onsuccess = onWhereRemove.call(this, res);\n        cursorRequest.onerror = rej\n    })\n\n}\n\n","import { BaseFetch } from \"../base_fetch\";\nimport { IRemoveQuery, QUERY_OPTION, API, IWhereQuery } from \"@/common\";\nimport { IDBUtil } from \"@/worker/idbutil\";\nimport { QueryHelper } from \"@executors/query_helper\";\nimport { promiseReject, isArray, getObjectFirstKey } from \"@/worker/utils\";\nimport { Select } from \"@executors/select\";\nimport { executeWhereUndefinedLogic } from \"./not_where\";\nimport { executeInLogic } from \"./in\";\nimport { executeWhereLogic } from \"./where\";\nimport { executeRegexLogic } from \"./regex\";\n\nexport class Remove extends BaseFetch {\n    isOr;\n    executeWhereUndefinedLogic;\n\n    constructor(\n        query: IRemoveQuery, util: IDBUtil\n    ) {\n        super();\n        this.query = query;\n        this.util = util;\n        this.tableName = query.from;\n    }\n\n    execute(beforeExecute: () => Promise<any>) {\n        const queryHelper = new QueryHelper(this.db);\n        const query = this.query;\n        const err = queryHelper.validate(API.Remove, query);\n        if (err) return promiseReject(\n            err\n        );\n        let pResult: Promise<void>;\n        return beforeExecute().then(_ => {\n            try {\n                this.initTransaction_();\n                if (query.where != null) {\n                    if (isArray(query.where)) {\n                        pResult = this.processWhereArrayQry();\n                    }\n                    else {\n                        pResult = this.processWhere_();\n                    }\n                }\n                else {\n                    pResult = this.executeWhereUndefinedLogic();\n                }\n\n            }\n            catch (ex) {\n                return this.onException(ex);\n            }\n            return pResult.then(() => {\n                return this.rowAffected;\n            })\n        })\n    }\n\n    private processWhereArrayQry() {\n        const selectObject = new Select(this.query, this.util);\n        selectObject.isTxQuery = this.isTxQuery;\n        return selectObject.execute().then((results) => {\n            const keyList = [];\n            const pkey = this.primaryKey(this.query.from);\n            results.forEach((item) => {\n                keyList.push(item[pkey]);\n            });\n            results = null;\n            const whereQry = { [pkey]: { [QUERY_OPTION.In]: keyList } };\n            this.query[QUERY_OPTION.Where] = whereQry;\n            return this.processWhere_();\n        })\n    }\n\n    private processWhere_() {\n        this.shouldAddValue = (value) => {\n            return this.whereChecker.check(value);\n        };\n        if ((this.query.where as IWhereQuery).or) {\n            this.processOrLogic();\n        }\n        return this.goToWhereLogic().then(() => {\n            return this.onWhereEvaluated();\n        });\n    }\n\n    private initTransaction_() {\n        if (!this.isTxQuery) {\n            this.util.createTransaction([this.query.from]);\n        }\n        this.objectStore = this.util.objectStore(this.query.from);\n    }\n\n    private onWhereEvaluated() {\n        if (this.isOr) {\n            return this.orQuerySuccess_();\n        }\n    }\n\n    private orQuerySuccess_() {\n        const orQueryFromOrInfo = (this as any)._orInfo.OrQuery\n        const key = getObjectFirstKey(orQueryFromOrInfo);\n        if (key != null) {\n            const where = {};\n            where[key] = orQueryFromOrInfo[key];\n            delete orQueryFromOrInfo[key];\n            this.query.where = where;\n            return this.goToWhereLogic().then(() => {\n                return this.onWhereEvaluated();\n            })\n        }\n        else {\n            this.isOr = true;\n        }\n    }\n\n    private processOrLogic() {\n        this.isOr = true;\n        const where = this.query.where as IWhereQuery;\n        (this as any)._orInfo = {\n            OrQuery: where.or\n        };\n\n        // free or memory\n        delete where.or;\n    }\n}\n\nRemove.prototype.executeInLogic = executeInLogic;\nRemove.prototype.executeWhereUndefinedLogic = executeWhereUndefinedLogic;\nRemove.prototype.executeWhereLogic = executeWhereLogic;\nRemove.prototype.executeRegexLogic = executeRegexLogic;","import { Remove } from \".\";\nimport { promise, promiseAll } from \"@/common\";\nimport { onWhereRemove } from \"./where\";\n\nexport const executeInLogic = function (this: Remove, column, values) {\n    const columnIndex = this.objectStore.index(column)\n    const runInLogic: (val) => Promise<void> = (value) => {\n        return promise((res, rej) => {\n            const cursorRequest = columnIndex.openCursor(this.util.keyRange(value));\n            cursorRequest.onsuccess = onWhereRemove.call(this, res);\n            cursorRequest.onerror = rej;\n        });\n    };\n\n    return promiseAll<void>(\n        values.map(function (val) {\n            return runInLogic(val);\n        })\n    );\n}\n","import { Remove } from \".\";\nimport { promise } from \"@/common\";\n\nexport const executeWhereUndefinedLogic = function (this: Remove) {\n    let cursor;\n    const cursorRequest = this.objectStore.openCursor();\n    return promise<void>((res, rej) => {\n        cursorRequest.onsuccess = (e: any) => {\n            cursor = e.target.result;\n            if (cursor) {\n                cursor.delete();\n                ++this.rowAffected;\n                (cursor as any).continue();\n            }\n            else {\n                res();\n            }\n        };\n        cursorRequest.onerror = rej;\n    })\n\n}\n","import { Remove } from \"./\";\nimport { promise } from \"@/common\";\n\nexport const executeRegexLogic = function (this: Remove, column: string, exp: RegExp) {\n    let cursor: IDBCursorWithValue;\n    const cursorRequest = this.objectStore.index(column).openCursor();\n    this.shouldAddValue = (cursor) => {\n        return exp.test(cursor.key) &&\n            this.whereChecker.check(cursor.value);\n    };\n    return promise<void>((res, rej) => {\n        cursorRequest.onsuccess = (e: any) => {\n            cursor = e.target.result;\n            if (cursor) {\n                if (this.shouldAddValue(cursor)) {\n                    cursor.delete();\n                    ++this.rowAffected;\n                }\n                cursor.continue();\n            }\n            else {\n                res();\n            }\n        };\n        cursorRequest.onerror = rej;\n    })\n\n}","import { Base } from \"@executors/base\";\nimport { IDBUtil } from \"@/worker/idbutil\";\nimport { MetaHelper } from \"@/worker/meta_helper\";\nimport { promise } from \"@/common\";\n\nexport class Clear extends Base {\n    constructor(tableName: string, util: IDBUtil) {\n        super();\n        this.query = tableName as any;\n        this.util = util;\n        this.tableName = tableName;\n    }\n\n    execute(beforeExecute: () => Promise<any>) {\n        const tableName: string = this.query as any;\n        if (!this.isTxQuery) {\n            this.util.createTransaction([tableName, MetaHelper.tableName]);\n        }\n        return beforeExecute().then(_ => {\n            const clearRequest: IDBRequest = this.util.objectStore(tableName).clear();\n            try {\n                return promise<void>((res, rej) => {\n                    clearRequest.onsuccess = (e) => {\n                        const currentTable = this.table(tableName);\n                        for (const columnName in currentTable.autoIncColumnValue) {\n                            currentTable.autoIncColumnValue[columnName] = 0;\n                        }\n                        MetaHelper.set(MetaHelper.dbSchema, this.util.db, this.util).then(res).catch(rej);\n                    };\n\n                    clearRequest.onerror = rej;\n                })\n            }\n            catch (ex) {\n                return this.onException(ex);\n            }\n        })\n    }\n}","import { Base } from \"@executors/base\";\nimport { ITranscationQuery, WebWorkerRequest, ERROR_TYPE, API, WebWorkerResult, promise } from \"@/common\";\nimport { IDBUtil } from \"@worker/idbutil\";\nimport { promiseReject, LogHelper, variableFromPath } from \"@worker/utils\";\nimport { Insert } from \"@executors/insert\";\nimport { Select } from \"@executors/select\";\nimport { Count } from \"@executors/count\";\nimport { Update } from \"@executors/update\";\nimport { Remove } from \"@executors/remove\";\nimport { IQueryExecutor } from \"@/worker/interfaces\";\nimport { MetaHelper } from \"@/worker/meta_helper\";\n\nexport class Transaction extends Base {\n    results = {} as any;\n    reqQueue: WebWorkerRequest[] = [];\n    isQueryExecuting = false;\n\n    isTxStarted_ = false;\n\n    onSuccess: (result: any) => void;\n    onError: (err: LogHelper) => void;\n\n    beforeExecute: () => Promise<void>;\n\n    constructor(qry: ITranscationQuery, util: IDBUtil) {\n        super();\n        this.query = qry as any;\n        this.util = util;\n    }\n\n    execute(cb: () => Promise<void>) {\n        this.beforeExecute = cb;\n        const err = this.validate();\n        if (err) return promiseReject(\n            err\n        );\n        this.startExecution_()\n\n        return promise<void>((res, rej) => {\n            this.onSuccess = res;\n            this.onError = rej;\n        }).then(result => {\n            this.beforeExecute = null;\n            this.log(`transaction finished`);\n            return result;\n        })\n    }\n\n    validate() {\n        const query: ITranscationQuery = this.query as any;\n        const notExistingTable = this.notExistingTable_(query.tables);\n        if (notExistingTable) {\n            return new LogHelper(ERROR_TYPE.TableNotExist, { tableName: notExistingTable });\n        }\n        const methodName = query.method;\n        let txLogic = variableFromPath(methodName);\n        if (!txLogic) {\n            return new LogHelper(ERROR_TYPE.MethodNotExist, methodName);\n        }\n    }\n\n    private startExecution_() {\n        const query: ITranscationQuery = this.query as any;\n        const createPusher = (api: any) => {\n            return (qry) => {\n                return this.pushReq_({\n                    name: api,\n                    query: qry\n                } as WebWorkerRequest);\n            }\n        };\n        const setResult = (key: string, value) => {\n            this.results[key] = value;\n        };\n        const getResult = (key: string) => {\n            return this.results[key];\n        };\n        const abort = (msg: string) => {\n            this.abortTx_(msg);\n        };\n\n        const start = () => {\n            this.startTx_();\n        };\n        const methodName = query.method\n        let txLogic = variableFromPath(methodName);\n\n        this.log(`transaction query started`);\n\n        return txLogic.call(\n            this,\n            {\n                data: query.data,\n                insert: createPusher(API.Insert),\n                select: createPusher(API.Select),\n                update: createPusher(API.Update),\n                remove: createPusher(API.Remove),\n                count: createPusher(API.Count),\n                setResult: setResult,\n                getResult: getResult, abort: abort,\n                start: start\n            }\n        );\n    }\n\n    log(message) {\n        this.util.logger.log(message);\n    }\n\n    private startTx_() {\n        try {\n            this.isTxStarted_ = true;\n            let tableNames = (this.query as any).tables as string[];\n            tableNames = tableNames.concat(MetaHelper.tableName)\n            this.util.createTransaction(tableNames).then(_ => {\n                this.onSuccess(this.results);\n            }).catch(err => {\n                this.onError(err);\n            })\n            return this.processExecutionOfQry_();\n        }\n        catch (ex) {\n            this.onError(this.onException(ex) as any);\n        }\n    }\n\n\n\n\n\n    private onReqFinished_(result) {\n        const finisehdRequest = this.reqQueue.shift();\n\n        this.log(`finished request : ${finisehdRequest.name} `);\n\n        if (finisehdRequest) {\n            if (result.error) {\n                this.abortTx_(\"automatic abort of transaction due to error occured\");\n                this.log(`transaction aborted due to error occured`);\n                this.onError(result.error);\n            }\n            else {\n                this.isQueryExecuting = false;\n                if (finisehdRequest.onSuccess) {\n                    finisehdRequest.onSuccess(result);\n                }\n                this.processExecutionOfQry_();\n            }\n        }\n    }\n\n    private abortTx_(msg: string) {\n        this.reqQueue = [];\n        this.util.abortTransaction();\n        this.log(`transaction aborted. Msg : ${msg}`);\n\n    }\n\n    private executeRequest_(request: WebWorkerRequest) {\n        this.isQueryExecuting = true;\n        let requestObj: IQueryExecutor;\n        this.log(`executing request : ${request.name} `);\n        const onReqFinished = this.onReqFinished_.bind(this);\n        const query = request.query;\n\n        const callAPI = (api: typeof Select) => {\n            requestObj = new api(\n                query, this.util\n            );\n        };\n\n        switch (request.name) {\n            case API.Select:\n                callAPI(Select);\n                break;\n            case API.Insert:\n                callAPI(Insert as any);\n                break;\n            case API.Update:\n                callAPI(Update as any);\n                break;\n            case API.Remove:\n                callAPI(Remove as any);\n                break;\n            case API.Count:\n                callAPI(Count as any);\n                break;\n        }\n        requestObj.isTxQuery = true;\n        requestObj.execute(this.beforeExecute).then(onReqFinished).catch(err => {\n            const result = {\n                error: err\n            } as WebWorkerResult;\n            onReqFinished(result);\n        })\n    }\n\n    private pushReq_(request: WebWorkerRequest) {\n        const promiseObj = promise((resolve, reject) => {\n            request.onSuccess = (result) => {\n                resolve(result);\n            };\n            request.onError = (error) => {\n                reject(error);\n            };\n        });\n        this.reqQueue.push(request);\n        if (this.isTxStarted_ === true) {\n            this.processExecutionOfQry_();\n        }\n\n        this.log(`request pushed : ${request.name}`);\n        return promiseObj;\n    }\n\n    private processExecutionOfQry_() {\n        if (this.isQueryExecuting === false) {\n            if (this.reqQueue.length > 0) {\n                this.executeRequest_(this.reqQueue[0]);\n            }\n        }\n    }\n\n    private notExistingTable_(tables: string[]) {\n        let invalidTable: string = null;\n        tables.every(tableName => {\n            const table = this.table(tableName);\n            if (table == null) {\n                invalidTable = tableName;\n                return false;\n            }\n            return true;\n        });\n        return invalidTable;\n    }\n}","import { DbMeta } from \"@worker/model\";\nimport { IDataBase, ITable } from \"@/common\";\n\nexport const userDbSchema = (db: DbMeta) => {\n    if (db == null) {\n        throw new Error(`userDbSchema db is null`);\n    }\n    const database = {\n        name: db.name,\n        version: db.version,\n        tables: []\n    } as IDataBase;\n    db.tables.forEach(table => {\n        const tableAsObj = {\n            name: table.name,\n            columns: {}\n        } as ITable;\n        table.columns.forEach(column => {\n            tableAsObj.columns[column.name] = column;\n        });\n        database.tables.push(tableAsObj);\n    })\n    return database;\n}","import { WebWorkerRequest, promiseResolve, API, IDataBase, WebWorkerResult, promise, ERROR_TYPE, IDbInfo, InitDbResult } from \"@/common\";\nimport { DbMeta } from \"./model\";\nimport { IDBUtil } from \"./idbutil\";\nimport { Insert } from \"@executors/insert\";\nimport { IS_WORKER, IS_IDB_SUPPORTED } from \"./constants\";\nimport { MetaHelper } from \"./meta_helper\";\nimport { Select } from \"@executors/select\";\nimport { Count } from \"@executors/count\";\nimport { Update } from \"@executors/update\";\nimport { Intersect } from \"./intersect\";\nimport { DropDb } from \"@executors/drop_db\";\nimport { Union } from \"./union\";\nimport { Remove } from \"@executors/remove\";\nimport { Clear } from \"@executors/clear\";\nimport { Transaction } from \"@executors/transaction\";\nimport { LogHelper, getError, promiseReject, variableFromPath, userDbSchema, getLength } from \"@worker/utils\";\n\nexport class QueryManager {\n    util: IDBUtil;\n\n    get db() {\n        return this.util.db;\n    }\n\n    middlewares: string[] = [];\n\n    private onQryFinished;\n\n    protected get logger() {\n        return this.util.logger;\n    }\n\n    constructor(fn?: (result: any) => void) {\n        this.util = new IDBUtil();\n        this.onQryFinished = IS_WORKER ? (result) => {\n            self.postMessage(result);\n        } : fn;\n    }\n\n    private executeMiddleware_(request: WebWorkerRequest) {\n        const lastIndex = (getLength(this.middlewares) as any) - 1;\n        if (lastIndex < 0) {\n            return promiseResolve();\n        }\n        const middlewareContext = {};\n        const db = this.db;\n        Object.defineProperty(middlewareContext, 'database', {\n            get() {\n                return userDbSchema(db);\n            }\n        });\n        return promise<void>((res) => {\n            let index = 0;\n            const callNextMiddleware = () => {\n                if (index <= lastIndex) {\n                    let promiseResult = variableFromPath(this.middlewares[index++])(request, middlewareContext);\n                    if (!promiseResult || !promiseResult.then) {\n                        promiseResult = Promise.resolve(promiseResult);\n                    }\n                    promiseResult.then(_ => {\n                        callNextMiddleware();\n                    });\n                }\n                else {\n                    res();\n                }\n            };\n            callNextMiddleware();\n        });\n    }\n\n    executeQuery(request: WebWorkerRequest, cb: () => Promise<any>) {\n        let queryResult: Promise<any>;\n        const query = request.query;\n        const ctx = this;\n        const idbutil = ctx.util;\n        const callAPI = (api: typeof Select, beforeExecute?: () => Promise<any>) => {\n            queryResult = new api(query, idbutil).\n                execute(beforeExecute);\n        };\n        switch (request.name) {\n            case API.OpenDb:\n                cb();\n                queryResult = ctx.openDb(query);\n                break;\n            case API.InitDb:\n                cb();\n                queryResult = ctx.initDb(query);\n                break;\n            case API.CloseDb:\n                cb();\n                queryResult = ctx.closeDb();\n                break;\n            case API.Insert:\n                callAPI(Insert as any, cb);\n                break;\n            case API.Select:\n                callAPI(Select as any, cb);\n                break;\n            case API.Count:\n                callAPI(Count as any, cb);\n                break;\n            case API.Update:\n                callAPI(Update as any, cb);\n                break;\n            case API.Intersect:\n                cb();\n                callAPI(Intersect as any);\n                break;\n            case API.DropDb:\n                cb();\n                queryResult = ctx.dropDb();\n                break;\n            case API.Terminate:\n                cb();\n                queryResult = ctx.terminate();\n                break;\n            case API.Union:\n                cb();\n                callAPI(Union as any);\n                break;\n            case API.Remove:\n                callAPI(Remove as any, cb);\n                break;\n            case API.Clear:\n                callAPI(Clear as any, cb);\n                break;\n            case API.Transaction:\n                callAPI(Transaction as any, cb);\n                break;\n            case API.MapGet:\n                cb();\n                queryResult = MetaHelper.get(query as string, idbutil);\n                break;\n            case API.MapSet:\n                cb();\n                queryResult = MetaHelper.set(query.key, query.value, idbutil);\n                break;\n            case API.MapHas:\n                cb();\n                queryResult = MetaHelper.has(query as string, idbutil);\n                break;\n            case API.MapDelete:\n                cb();\n                queryResult = MetaHelper.remove(query as string, idbutil);\n                break;\n            case API.ImportScripts:\n                cb();\n                queryResult = ctx.importScripts_(request);\n                break;\n            case API.ChangeLogStatus:\n                cb();\n                ctx.logger.status = query;\n                queryResult = Promise.resolve();\n                break;\n            case API.Middleware:\n                cb();\n                const value = variableFromPath(query);\n                if (!value) {\n                    return promiseReject(\n                        new LogHelper(ERROR_TYPE.InvalidMiddleware, query)\n                    );\n                }\n                ctx.middlewares.push(query);\n                return promiseResolve();\n            default:\n                if (process.env.NODE_ENV !== 'production') {\n                    console.error('The Api:-' + request.name + ' does not support.');\n                }\n                queryResult = promiseResolve();\n        }\n        ctx.logger.log(`Executing query ${request.name} in web worker`);\n        return queryResult;\n    }\n\n    private callMiddleware_(middlewares: any[], result?) {\n        return promise<any>((res) => {\n            let index = 0;\n            const lastIndex = (getLength(middlewares) as any) - 1;\n            const callNextMiddleware = () => {\n                if (index <= lastIndex) {\n                    let promiseResult = middlewares[index++](result);\n                    if (!(promiseResult instanceof Promise)) {\n                        promiseResult = promiseResolve(promiseResult);\n                    }\n                    promiseResult.then(modifiedResult => {\n                        result = modifiedResult;\n                        callNextMiddleware();\n                    });\n                }\n                else {\n                    res(result);\n                }\n            };\n            callNextMiddleware();\n        });\n    }\n\n    run(request: WebWorkerRequest) {\n        let onResultCallback = [];\n        const beforeExecuteCallback = [];\n        request.onResult = (cb) => {\n            onResultCallback.push((result) => {\n                return cb(result);\n            });\n        };\n        request.beforeExecute = (cb) => {\n            beforeExecuteCallback.push((result) => {\n                return cb(result);\n            });\n        };\n        this.executeMiddleware_(request).then(_ => {\n            return this.executeQuery(request, () => {\n                return this.callMiddleware_(beforeExecuteCallback);\n            }).then((result) => {\n                return this.callMiddleware_(onResultCallback, result).then(modifiedResult => {\n                    this.returnResult_({\n                        result: modifiedResult\n                    });\n                });\n            });\n        }).catch(ex => {\n            onResultCallback = [];\n            const err = getError(ex);\n            const result = {\n                error: err\n            } as WebWorkerResult;\n            this.returnResult_(result);\n        });\n    }\n\n    private importScripts_(request: WebWorkerRequest) {\n        return promise<void>((res, rej) => {\n            try {\n                importScripts(...request.query);\n                res();\n            } catch (e) {\n                const err = new LogHelper(ERROR_TYPE.ImportScriptsFailed, e.message);\n                rej(err);\n            }\n        });\n    }\n\n    private returnResult_(result: WebWorkerResult) {\n        this.logger.log(`Query finished inside web worker`);\n        if (this.util) {\n            this.util.emptyTx();\n        }\n        this.onQryFinished(result);\n    }\n\n    private dropDb() {\n        const dbName = this.db.name;\n        return this.terminate().then(() => {\n            return new DropDb().execute(dbName);\n        });\n    }\n\n    closeDb() {\n        return this.util.close();\n    }\n\n    terminate() {\n        return this.closeDb().then(() => {\n            this.util.db = null;\n        });\n    }\n\n    openDb(query: IDbInfo) {\n        return this.closeDb().then(_ => {\n            let pResult: Promise<InitDbResult>;\n            if (this.db && query.name === this.db.name) {\n                pResult = this.initDb();\n            }\n            else {\n                pResult = this.initDb({\n                    name: query.name,\n                    tables: [\n                    ],\n                    version: query.version\n                });\n            }\n            return pResult.then(() => {\n                return this.db;\n            });\n        });\n    }\n\n    initDb(dataBase?: IDataBase) {\n        if (!IS_IDB_SUPPORTED) {\n            return promiseReject(\n                new LogHelper(ERROR_TYPE.IndexedDbNotSupported)\n            );\n        }\n\n        const dbMeta = dataBase ? new DbMeta(dataBase) : this.db;\n        if (dbMeta == null) {\n            throw new Error(`dbMeta is null`);\n        }\n        this.util = new IDBUtil();\n\n        return this.util.initDb(dbMeta).then(dbInfo => {\n            return MetaHelper.get(\n                MetaHelper.dbSchema,\n                this.util\n            ).then((dbFromCache: DbMeta) => {\n                if (dbInfo.isCreated) {\n                    if (dbFromCache) {\n                        dbFromCache.tables.forEach((tableFromCache) => {\n                            const targetTable = dbMeta.tables.find(q => q.name === tableFromCache.name);\n                            if (targetTable) {\n                                for (const key in tableFromCache.autoIncColumnValue) {\n                                    const savedAutoIncrementValue = tableFromCache.autoIncColumnValue[key];\n                                    if (savedAutoIncrementValue) {\n                                        targetTable.autoIncColumnValue[key] = savedAutoIncrementValue;\n                                    }\n                                }\n                            }\n                        });\n                    }\n                    this.util.db = dbMeta;\n                    dbInfo.database = userDbSchema(this.db);\n                    return MetaHelper.set(\n                        MetaHelper.dbSchema, dbMeta,\n                        this.util\n                    ).then(() => {\n                        return dbInfo;\n                    });\n                }\n                else {\n                    return MetaHelper.get(\n                        MetaHelper.dbSchema,\n                        this.util\n                    ).then((value: any) => {\n                        this.util.db = value;\n                        dbInfo.database = userDbSchema(this.db);\n                        return dbInfo;\n                    });\n                }\n            });\n        });\n    }\n}\n","import { QueryManager } from \"@/worker/query_manager\";\nimport { IS_WORKER } from \"./constants\";\nexport * from \"./query_manager\";\n\nif (IS_WORKER) {\n    const manager = new QueryManager();\n    (self as any).onmessage = function (e) {\n        manager.run(e.data);\n    };\n}\n\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","WORKER_STATUS","DATA_TYPE","API","EVENT","QUERY_OPTION","IDB_MODE","OCCURENCE","CONNECTION_STATUS","promiseResolve","Promise","resolve","promise","cb","ERROR_TYPE","table","columns","autoIncColumnValue","this","setColumn","name","alter","tableColumns","columnName","column","autoIncrement","primaryKey","enableSearch","existingColumnIndex","indexOf","q","push","existingColumn","assign","autoIncrementKey","tableName","getStore","util","tx","createTransaction","MetaHelper","objectStore","set","store","res","rej","req","put","onsuccess","onerror","keyRange","result","remove","delete","has","count","dbSchema","db","version","tables","map","TableMeta","forObj","type","info","info_","message","getMsg_","log","msg","status","console","throw","logError","error","errMsg","errorHandler","getInfo","errorType","method","logger","LogHelper","emptyTx","oncomplete","onabort","createTransactionIfNotExist","mode","ReadWrite","con","transaction","op","Between","IDBKeyRange","bound","low","high","GreaterThan","lowerBound","GreaterThanEqualTo","LessThan","upperBound","LessThanEqualTo","only","abortTransaction","abort","close","setTimeout","initDb","oldVersion","isDbCreated","dbVersion","dbOpenRequest","indexedDB","open","onversionchange","e","target","isCreated","newVersion","onupgradeneeded","upgradeConnection","storeNames","objectStoreNames","addColumn","indexNames","contains","options","unique","multiEntry","keyPath","createIndex","deleteColumn","index","findIndex","splice","deleteIndex","forEach","option","createObjectStore","i","alterQuery","add","drop","modify","shouldDelete","targetColumn","find","newColumn","storeName","item","qry","deleteObjectStore","length","promiseAll","promises","all","promiseReject","reject","getError","rowAffected","isTxQuery","results","query","from","meta","getColumnInfo","onException","ex","getErrorFromException","getDataType","Null","Array","isArray","Date","DateTime","isNull","isNaN","autoIncValues","autoIncrementValue","checkAndModifyValues","err","values","ignoreIndexes","every","checkAndModifyValue","ignore","checkAndModifyColumnValue_","checkNotNullAndDataType_","notNull","ColumnName","dataType","columnValue","Number","undefined","default","validation","details","check","setValue","tblName","checkByColumn_","checkFurther","allowedOp","validate","api","Select","Remove","Count","checkSelect","Insert","checkInsertQuery","Update","checkUpdate","getTable_","isInsertQryValid","into","SchemaChecker","in","where","checkForNullInWhere_","addGreatAndLessToNotOp_","whereQuery","containsNot","keys","NotEqualTo","addToSingleQry","Or","queryKeys","qryKeys","validResult","skipDataCheck","ValuesChecker","valuesAffected_","execute","beforeInsert","QueryHelper","then","_","insertData_","return","catch","onInsertData","addMethod","idbMethod","upsert","addResult","Base","IS_WORKER","self","alert","ServiceWorkerGlobalScope","IS_IDB_SUPPORTED","mozIndexedDB","webkitIndexedDB","msIndexedDB","IDBTransaction","webkitIDBTransaction","msIDBTransaction","webkitIDBKeyRange","msIDBKeyRange","setCrossBrowserIndexedDb","getKeys","getLength","getObjectFirstKey","setCaseAndValue","caseQuery","caseQuery_","setCaseAndColumn","columnName_","caseColumnQuery_","length_","evaluate","checkCase_","lastThen","cond","queryOption","Equal","getCursorOnSuccess","simpleFn","limitFn","skipFn","skipAndLimitFn","limitAtEnd","skipAtEnd","skipRecord","limitRecord","executeSkipAndLimitForWhere_","onFinish","recordSkipped","cursor","shouldAddValue","pushResult","continue","advance","executeSkipForWhere_","executeLimitForWhere_","executeSimpleForWhere_","executeSkipAndLimit","onFinished","executeSkip","executeSimple","executeLimit","removeSpace","replace","getOrderColumnInfo","orderColumn","join","splittedByDot","split","joinOrderColumn","valueFromFirstColumn","isOrder","compareStringInDesc_","a","b","localeCompare","compareStringinAsc_","compareDefaultInDesc_","String","compareDefaultinAsc_","compareNumberInDesc_","compareNumberinAsc_","compareDateInDesc_","getTime","compareDateInAsc_","getValueComparer_","order","orderBy_","getOrderType_","by","thenEvaluator","getValInAscDesc","stringComparer","numberComparer","value1","value2","column1","column2","sortMethod","sort","columnInfo","case","toLowerCase","getRegexFromLikeExpression","likeExpression","filterValue","occurence","filterValues","Any","Last","First","RegExp","clone","copy","compare","compareValue","symbol","type1","checkFlag","props","last","pop","reduce","prev","curr","rowValue","whereColumnValue","isArrayColumnValue","isArrayWhereColumnValue","executeCompare","executor","In","checkIn","Like","checkLike_","Regex","checkRegex","checkComparisionOp_","storedValue","test","goToWhereLogic","firstColumn","whereChecker","WhereChecker","executeWhereLogic","regexVal","executeRegexLogic","executeInLogic","Aggregate","skipOrPush","select","joinQueryStack_","currentQueryStackIndex_","tablesFetched","getTable","executeSelect","tablesToFetch","joinQueryStack","jointblInfo","getJoinTableInfo_","on","with","table1","table2","checkJoinQuery_","joinTableInfo","whereQryParam","whereQryAfterJoin","filter","isWhereEmpty","filteredOr","whereQryOr","orColumn","whereQueryModified","removeJoinColumnResult","joinQuery","flatten","startExecutingJoinLogic_","onJoinQueryFinished_","selectApi","data","setLimitAndSkipEvaluationAtEnd_","processOrderBy","jointables","secondtableData","valueMatchedFromSecondTable","joinerComparer","defaultValueSetter","columnDefaultValue","joinType","output","table1Index","table2Index","asQuery","as","mapWithAlias","asValue","val","whereQry","whereCheker","col","valueFromSecondTable","valueFromFirstTable","joinOn","splittedjoinOn","splittedjoinOnbydotFirst","splittedjoinOnbydotSecond","tableSchemaOf1stTable","tableSchemaOf2ndTable","columnFound","whereJoinParam","whereForExtraColumn","openCursor","cursorRequest","callOnSuccess","includes","sorted","isSubQuery","ThenEvaluator","returnResult_","Map","concat","processGroupDistinctAggr","skip","slice","limit","setPushResult","isArrayQry","orderQuery","groupBy","beforeExecute","initTransaction_","processWhereArrayQry","processWhere_","executeWhereUndefinedLogic","executeJoinQuery","bind","operation","pKey","isFirstWhere","onSuccess","andResults","And","keyValue","removeDuplicates","processFirstQry","executeWhere","whereQueryToProcess","shift","whereQueryOr","MemoryObjectStore","ReadOnly","cursorValue","that","proxy","Proxy","p","receiver","or","processOrLogic_","onWhereEvaluated","isOr","orQuerySuccess_","orQueryFinish_","orInfo","orQuery","BaseFetch","idbSorting","orderType","dir","exp","datas","lookupObject","len","Join","distinct","aggregate","executeAggregateGroupBy","processGroupBy","processAggregateQry","orderQueryType","prevOrderQueryBy","currentOrderQuery","currentorderQueryBy","orderColumnDetail","columnToAggregate","datasLength","getCount","getMax","getMin","Infinity","getSum","getAvg","aggregateQry","aggregateColumn","aggregateValType","aggregateCalculator","objKey","grpQry","lookUpObj","calculateAggregate","getList","sumOfColumn","Max","Min","Sum","Avg","List","avgQuery","avg","sumForAvg","countForAvg","sum","isCountTypeString","isSumTypeString","avgColumn","groupByDataType","groupByColumn","onWhereCount","resultCount","queryHelper","getDataFromSelect","selectInstance","countRequest","isWhereKeysLengthOne","columnStore","variableFromPath","path","updateValue","mapSet","columnSetValue","initTransaction","executeComplexLogic_","selectObject","ignoreCase","inQuery","cursorUpdateRequest","update","cursorOpenRequest","intersectQry","getHashKey","hashMap","hashMapTemp","isQueryForSameTable","queries","queryLength","columnValKey","fetchData","selectResult","resultPusher","callBack","dbName","dropDbRequest","deleteDatabase","onblocked","onWhereRemove","pResult","keyList","pkey","Where","processOrLogic","orQueryFromOrInfo","_orInfo","OrQuery","columnIndex","clearRequest","clear","currentTable","reqQueue","isQueryExecuting","isTxStarted_","startExecution_","onError","notExistingTable","notExistingTable_","methodName","createPusher","pushReq_","txLogic","insert","setResult","getResult","abortTx_","start","startTx_","tableNames","processExecutionOfQry_","onReqFinished_","finisehdRequest","executeRequest_","request","requestObj","onReqFinished","callAPI","promiseObj","invalidTable","userDbSchema","Error","database","tableAsObj","fn","middlewares","IDBUtil","onQryFinished","postMessage","executeMiddleware_","lastIndex","middlewareContext","callNextMiddleware","promiseResult","executeQuery","queryResult","ctx","idbutil","OpenDb","openDb","InitDb","CloseDb","closeDb","Intersect","DropDb","dropDb","Terminate","terminate","Union","Clear","Transaction","MapGet","MapSet","MapHas","MapDelete","ImportScripts","importScripts_","ChangeLogStatus","Middleware","callMiddleware_","modifiedResult","run","onResultCallback","beforeExecuteCallback","onResult","importScripts","dataBase","dbMeta","DbMeta","dbInfo","dbFromCache","tableFromCache","targetTable","savedAutoIncrementValue","QueryManager","onmessage"],"sourceRoot":""}